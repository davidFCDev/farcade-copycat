<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Opensea Drop</title>
    <!-- Preload critical assets for faster loading -->
    <link
      rel="preload"
      href="https://lqy3lriiybxcejon.public.blob.vercel-storage.com/6d6bc837-fad6-47ee-91cd-cdfeb472750a/The%20Open-Sea%20%289%29-ldKqKPyTn8Ki18H1iohz4CMPw1PFOV.png?oG0m"
      as="image"
    />
    <link
      rel="preload"
      href="https://lqy3lriiybxcejon.public.blob.vercel-storage.com/6d6bc837-fad6-47ee-91cd-cdfeb472750a/demo-tileset-XdRc2ksEo7K0NQP8MMtzH0hcUz3RqS.png?Vagi"
      as="image"
    />
    <link
      rel="preload"
      href="https://lqy3lriiybxcejon.public.blob.vercel-storage.com/6d6bc837-fad6-47ee-91cd-cdfeb472750a/Pirate%20Captain%20%28Idle%29-d3UCZVEll9XXrrTtsHbdqzhQfDmEqT.png?AxwH"
      as="image"
    />
    <link
      rel="preload"
      href="https://lqy3lriiybxcejon.public.blob.vercel-storage.com/6d6bc837-fad6-47ee-91cd-cdfeb472750a/waves-bWs1OMPYRpODjTOSXkwhP9CNBPVEMm.mp3?01R0"
      as="audio"
    />
    <!-- Farcade SDK -->
    <script src="https://cdn.jsdelivr.net/npm/@farcade/game-sdk@latest/dist/index.min.js"></script>
    <!-- Google Fonts - Pirate/Adventure Style Font -->
    <link
      href="https://fonts.googleapis.com/css2?family=Pirata+One&family=Creepster&family=Jolly+Lodger&display=swap"
      rel="stylesheet"
    />
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        height: 100%;
      }
      body {
        color: white;
        background: linear-gradient(135deg, #1a1a2e, #16213e, #1e3a8a);
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: hidden;
        font-family: "Pirata One", sans-serif;
      }
      canvas {
        flex-shrink: 0;
        background-color: #000;
        object-fit: contain;
        image-rendering: auto;
      }
      .crisp {
        image-rendering: auto;
      }

      /* Canvas styles */
      canvas {
        image-rendering: pixelated;
        image-rendering: -moz-crisp-edges;
        image-rendering: crisp-edges;
        touch-action: none; /* Disable default touch behaviors */
        user-select: none; /* Prevent text selection on touch */
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
      }

      /* Touch feedback for mobile */
      .touch-feedback {
        position: fixed;
        width: 50px;
        height: 50px;
        border-radius: 50%;
        background: rgba(255, 215, 0, 0.3);
        border: 2px solid rgba(255, 215, 0, 0.6);
        pointer-events: none;
        z-index: 999;
        transform: translate(-50%, -50%);
        animation: touchFeedback 0.3s ease-out;
        display: none;
      }

      @keyframes touchFeedback {
        0% {
          transform: translate(-50%, -50%) scale(0.5);
          opacity: 1;
        }
        100% {
          transform: translate(-50%, -50%) scale(1.5);
          opacity: 0;
        }
      }

      /* All HUD and Control Pad styles will be created dynamically via JavaScript */
    </style>
    <script src="https://cdn.jsdelivr.net/npm/@farcade/game-sdk@latest/dist/index.min.js"></script>
  </head>
  <body>
    <!-- Touch feedback indicator -->
    <div id="touchFeedback" class="touch-feedback"></div>

    <script>
      // ----------
      // Utility
      // ----------
      Util = {};
      Util.timeStamp = function () {
        return window.performance.now();
      };
      Util.random = function (min, max) {
        return min + Math.random() * (max - min);
      };
      Util.array2D = function (tableau, largeur) {
        var result = [];
        for (var i = 0; i < tableau.length; i += largeur) result.push(tableau.slice(i, i + largeur));
        return result;
      };
      Util.toDio = function (array) {
        let tab = array.map((x) => {
          if (x !== 0) {
            return x - 1;
          } else {
            return x;
          }
        });
        let render = Util.array2D(tab, 16);
        return JSON.stringify(render);
      };
      Util.map = function (a, b, c, d, e) {
        return ((a - b) / (c - b)) * (e - d) + d;
      };
      Util.lerp = function (value1, value2, amount) {
        return value1 + (value2 - value1) * amount;
      };
      Util.linearTween = function (currentTime, start, degreeOfChange, duration) {
        return (degreeOfChange * currentTime) / duration + start;
      };
      Util.easeInOutQuad = function (t, b, c, d) {
        t /= d / 2;
        if (t < 1) return (c / 2) * t * t + b;
        t--;
        return (-c / 2) * (t * (t - 2) - 1) + b;
      };
      Util.easeInOutExpo = function (t, b, c, d) {
        t /= d / 2;
        if (t < 1) return (c / 2) * Math.pow(2, 10 * (t - 1)) + b;
        t--;
        return (c / 2) * (-Math.pow(2, -10 * t) + 2) + b;
      };

      // ========== MOBILE DETECTION AND CONTROL PAD MANAGEMENT ==========

      // Function to detect if the device is mobile
      function isMobileDevice() {
        const userAgent = navigator.userAgent || navigator.vendor || window.opera;

        // Check for mobile user agents
        const mobileRegex = /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i;

        // Check for touch capability and screen size
        const hasTouch = "ontouchstart" in window || navigator.maxTouchPoints > 0;
        const isSmallScreen = window.innerWidth <= 768;

        return mobileRegex.test(userAgent) || (hasTouch && isSmallScreen);
      }

      // ========== DYNAMIC HUD CREATION ==========
      let hudElements = {
        container: null,
        scoreElement: null,
        timerElement: null,
        surrenderButton: null,
      };

      function createGameHUD() {
        // Remove existing HUD if it exists
        if (hudElements.container) {
          hudElements.container.remove();
        }

        // Create main HUD container
        hudElements.container = document.createElement("div");
        hudElements.container.id = "gameHUD";
        hudElements.container.style.cssText = `
          position: fixed;
          top: 25px;
          left: 10px;
          right: 10px;
          display: none;
          z-index: 1000;
          pointer-events: none;
        `;

        // Create inner container
        const hudInner = document.createElement("div");
        hudInner.style.cssText = `
          display: flex;
          justify-content: center;
          gap: 80px;
          align-items: flex-start;
          width: 100%;
          max-width: 800px;
          margin: 0 auto;
          padding: 0 20px;
          box-sizing: border-box;
        `;

        // Create left side (Score and Timer)
        const hudLeft = document.createElement("div");
        hudLeft.style.cssText = `
          display: flex;
          flex-direction: column;
          align-items: flex-start;
        `;

        // Create score display
        const scoreDisplay = document.createElement("div");
        scoreDisplay.style.cssText = `
          font-family: "Pirata One", serif;
          font-size: clamp(20px, 6vw, 40px);
          color: #ffffff;
          text-shadow: 3px 3px 0px rgba(0, 0, 0, 0.8);
          margin: 5px 0;
          line-height: 1;
        `;
        scoreDisplay.innerHTML = 'Score: <span id="scoreValue">0</span>';
        hudElements.scoreElement = scoreDisplay;

        // Create timer display
        const timerDisplay = document.createElement("div");
        timerDisplay.style.cssText = `
          font-family: "Pirata One", serif;
          font-size: clamp(20px, 6vw, 40px);
          color: #ffffff;
          text-shadow: 3px 3px 0px rgba(0, 0, 0, 0.8);
          margin: 5px 0;
          line-height: 1;
        `;
        timerDisplay.innerHTML = 'Time: <span id="timerValue">30</span>';
        hudElements.timerElement = timerDisplay;

        // Create right side (Surrender button)
        const hudRight = document.createElement("div");
        hudRight.style.cssText = `
          display: flex;
          flex-direction: column;
          align-items: flex-end;
        `;

        // Create surrender button
        hudElements.surrenderButton = document.createElement("button");
        hudElements.surrenderButton.id = "surrenderBtn";
        hudElements.surrenderButton.title = "Surrender";
        hudElements.surrenderButton.style.cssText = `
          background: url("https://lqy3lriiybxcejon.public.blob.vercel-storage.com/6d6bc837-fad6-47ee-91cd-cdfeb472750a/redbutton-m50kIc64V6BJZuyeQESCLuOxNHTJcg.png?lhaA") no-repeat center;
          background-size: contain;
          width: clamp(55px, 12vw, 85px);
          height: clamp(55px, 12vw, 85px);
          border: none;
          cursor: pointer;
          pointer-events: auto;
          transition: transform 0.1s;
          margin-top: 7px;
        `;

        // Add hover and active effects
        hudElements.surrenderButton.addEventListener("mouseenter", () => {
          hudElements.surrenderButton.style.transform = "scale(1.1)";
        });
        hudElements.surrenderButton.addEventListener("mouseleave", () => {
          hudElements.surrenderButton.style.transform = "scale(1)";
        });
        hudElements.surrenderButton.addEventListener("mousedown", () => {
          hudElements.surrenderButton.style.transform = "scale(0.95)";
        });
        hudElements.surrenderButton.addEventListener("mouseup", () => {
          hudElements.surrenderButton.style.transform = "scale(1.1)";
        });

        // Assemble the HUD
        hudLeft.appendChild(scoreDisplay);
        hudLeft.appendChild(timerDisplay);
        hudRight.appendChild(hudElements.surrenderButton);
        hudInner.appendChild(hudLeft);
        hudInner.appendChild(hudRight);
        hudElements.container.appendChild(hudInner);

        // Add to document
        document.body.appendChild(hudElements.container);
      }

      // ========== DYNAMIC CONTROL PAD CREATION ==========
      let controlPadElements = {
        container: null,
        buttons: [],
      };

      function createControlPad() {
        // Only create control pad for mobile devices
        if (!isMobileDevice()) {
          return;
        }

        // Remove existing control pad if it exists
        if (controlPadElements.container) {
          controlPadElements.container.remove();
        }

        // Calculate responsive size based on screen dimensions
        const screenWidth = window.innerWidth;
        const screenHeight = window.innerHeight;

        // Base size calculation - use a larger percentage of screen for better visibility
        let padSize = Math.min(screenWidth * 0.32, screenHeight * 0.25);
        padSize = Math.max(160, Math.min(280, padSize)); // Min 160px, Max 280px (increased from 140-220)

        // Calculate font size based on pad size
        const fontSize = Math.max(22, padSize * 0.16);

        // Calculate bottom margin based on screen height (reduced by a few pixels)
        const bottomMargin = Math.max(10, screenHeight * 0.015);

        console.log("Control pad sizing:", {
          screenWidth,
          screenHeight,
          padSize,
          fontSize,
          bottomMargin,
        });

        // Create main control pad container
        controlPadElements.container = document.createElement("div");
        controlPadElements.container.id = "controlPad";
        controlPadElements.container.style.cssText = `
          position: fixed;
          bottom: ${bottomMargin}px;
          left: 50%;
          transform: translateX(-50%);
          width: ${padSize}px;
          height: ${padSize}px;
          z-index: 1000;
          display: none;
        `;

        // Create control grid
        const controlGrid = document.createElement("div");
        controlGrid.style.cssText = `
          display: grid;
          grid-template-columns: 1fr 1fr 1fr;
          grid-template-rows: 1fr 1fr 1fr;
          width: 100%;
          height: 100%;
          gap: 4px;
        `;

        // Create control buttons
        const buttonConfigs = [
          { direction: "up", symbol: "↑", gridColumn: "2", gridRow: "1" },
          { direction: "left", symbol: "←", gridColumn: "1", gridRow: "2" },
          { direction: "right", symbol: "→", gridColumn: "3", gridRow: "2" },
          { direction: "down", symbol: "↓", gridColumn: "2", gridRow: "3" },
        ];

        controlPadElements.buttons = [];

        buttonConfigs.forEach((config) => {
          const button = document.createElement("div");
          button.className = `control-button ${config.direction}`;
          button.setAttribute("data-direction", config.direction);
          button.textContent = config.symbol;
          button.style.cssText = `
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #444;
            border-radius: ${Math.max(6, padSize * 0.04)}px;
            color: #fff;
            font-size: ${fontSize}px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
            touch-action: manipulation;
            transition: all 0.1s ease;
            cursor: pointer;
            grid-column: ${config.gridColumn};
            grid-row: ${config.gridRow};
            min-height: ${(padSize - 12) / 3}px;
          `;

          // Add touch event handlers
          button.addEventListener("touchstart", (e) => {
            e.preventDefault();
            e.stopPropagation();
            handleControlPadInput(config.direction);
            button.style.background = "rgba(255, 255, 255, 0.4)";
            button.style.borderColor = "#fff";
            button.style.transform = "scale(0.9)";
          });

          button.addEventListener("touchend", (e) => {
            e.preventDefault();
            e.stopPropagation();
            button.style.background = "rgba(0, 0, 0, 0.8)";
            button.style.borderColor = "#444";
            button.style.transform = "scale(1)";
          });

          // Add mouse events for desktop testing on mobile
          button.addEventListener("mousedown", (e) => {
            e.preventDefault();
            e.stopPropagation();
            handleControlPadInput(config.direction);
            button.style.background = "rgba(255, 255, 255, 0.4)";
            button.style.borderColor = "#fff";
            button.style.transform = "scale(0.9)";
          });

          button.addEventListener("mouseup", (e) => {
            e.preventDefault();
            e.stopPropagation();
            button.style.background = "rgba(0, 0, 0, 0.8)";
            button.style.borderColor = "#444";
            button.style.transform = "scale(1)";
          });

          // Prevent context menu
          button.addEventListener("contextmenu", (e) => {
            e.preventDefault();
          });

          controlPadElements.buttons.push(button);
          controlGrid.appendChild(button);
        });

        controlPadElements.container.appendChild(controlGrid);
        document.body.appendChild(controlPadElements.container);
      }

      function handleControlPadInput(direction) {
        if (!game || !game.current_scene || game.current_scene.name !== "inGame") {
          return;
        }

        let moveX = 0,
          moveY = 0;

        switch (direction) {
          case "up":
            moveY = -1;
            break;
          case "down":
            moveY = 1;
            break;
          case "left":
            moveX = -1;
            break;
          case "right":
            moveX = 1;
            break;
        }

        if (moveX !== 0 || moveY !== 0) {
          console.log("Control pad input:", direction, moveX, moveY);
          game.current_scene.moveCats(moveX, moveY);
        }
      }

      // Function to show/hide control pad based on device and game state
      function updateControlPadVisibility(currentScene) {
        if (!controlPadElements.container) return;

        // Only show control pad if:
        // 1. It's a mobile device
        // 2. AND we're currently in the game (inGame scene)
        const shouldShow = isMobileDevice() && currentScene === "inGame";

        controlPadElements.container.style.display = shouldShow ? "block" : "none";

        console.log("Control pad visibility updated:", {
          isMobile: isMobileDevice(),
          currentScene: currentScene,
          shouldShow: shouldShow,
        });
      }

      // Function to recreate control pad with new sizing (for orientation changes)
      function recreateControlPad() {
        if (!isMobileDevice()) return;

        const wasVisible = controlPadElements.container && controlPadElements.container.style.display === "block";

        // Recreate the control pad with new dimensions
        createControlPad();

        // Restore visibility if it was visible before
        if (wasVisible && game && game.current_scene && game.current_scene.name === "inGame") {
          updateControlPadVisibility("inGame");
        }

        console.log("Control pad recreated due to screen size change");
      }

      // ========== END MOBILE DETECTION AND CONTROL PAD MANAGEMENT ==========

      // ----------
      // Scene
      // ----------
      class Scene {
        constructor(name) {
          this.name = name;
          this.loop = true;
          this.init_once = false;
        }
        giveWorld(world) {
          this.world = world;
          this.ctx = world.ctx;
        }
        keyEvents(event) {}
        init() {}
        render() {}
        addEntity() {}
      }
      class Entity {
        constructor(scene, x, y) {
          this.scene = scene;
          this.world = scene.world;
          this.ctx = this.world.ctx;
          this.body = new Body(this, x, y);
        }
        setSprite(sprite_data) {
          this.sprite = new Sprite(this, sprite_data);
        }
        display() {
          if (this.playerSprite !== undefined) {
            this.playerSprite.display();
          } else if (this.sprite === undefined) {
            this.ctx.strokeStyle = "#000";
            this.ctx.strokeRect(this.body.position.x, this.body.position.y, this.body.size.x, this.body.size.y);
          } else {
            this.sprite.display();
          }
        }
        integration() {
          this.body.integration();
        }
      }

      // class for animated sprites !
      class Sprite {
        constructor(entity, sprite_data) {
          this.entity = entity;
          this.world = this.entity.world;
          this.tile_size = this.world.tile_size;
          this.ctx = this.world.ctx;
          // image data
          this.image = this.world.assets.image[sprite_data.image].image;
          // sprite
          this.size = sprite_data.size;
          this.current_frame = 0;
          this.animations = {};
          this.current_animation = undefined;
          this.width = this.image.width / this.size.x;
          this.height = this.image.height / this.size.y;
          // timer
          this.tick = 0;
          this.speed = 0.2;
          // offset
          this.offset = {
            x: 0,
            y: 0,
          };
        }
        addAnimation(name, frames) {
          this.animations[name] = frames;
          this.current_animation = name;
        }
        animate(animation_name) {
          this.current_animation = animation_name;
          if (this.tick < 1) {
            this.tick += this.speed;
          } else {
            this.tick = 0;
            if (this.current_frame < this.animations[animation_name].length - 1) {
              this.current_frame += 1;
            } else {
              this.current_frame = 0;
            }
          }
        }
        display() {
          this.ctx.drawImage(
            this.image,
            Math.floor(this.animations[this.current_animation][this.current_frame] % this.width) * this.size.x,
            Math.floor(this.animations[this.current_animation][this.current_frame] / this.width) * this.size.y,
            this.size.x,
            this.size.y,
            this.entity.body.position.x + (this.tile_size / 2 - this.size.x / 2) + this.offset.x,
            this.entity.body.position.y + (this.tile_size / 2 - this.size.x / 2) + this.offset.y,
            this.size.x,
            this.size.y,
          );
        }
      }

      // PlayerSprite class for managing multiple sprites and states
      class PlayerSprite {
        constructor(entity, idle_sprite_data, walk_sprite_data) {
          this.entity = entity;
          this.world = this.entity.world;
          this.ctx = this.world.ctx;

          // Create sprites for different states
          this.idleSprite = new Sprite(entity, idle_sprite_data);
          this.walkSprite = new Sprite(entity, walk_sprite_data);

          // Setup animations
          this.setupAnimations();

          // Current state
          this.currentState = "idle";
          this.currentSprite = this.idleSprite;

          // Movement tracking
          this.isMoving = false;
          this.lastPosition = {
            x: entity.body.position.x,
            y: entity.body.position.y,
          };
        }

        setupAnimations() {
          // Idle animation: 6 frames (192x32, so each frame is 32x32)
          this.idleSprite.addAnimation("idle", [0, 1, 2, 3, 4, 5]);
          this.idleSprite.speed = 0.15;

          // Walk animation: 12 frames (384x32, so each frame is 32x32)
          this.walkSprite.addAnimation("walk", [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]);
          this.walkSprite.speed = 0.25;
        }

        updateMovementState() {
          // Check if entity is moving by comparing positions
          const currentPos = this.entity.body.position;
          const hasPositionChanged =
            Math.abs(currentPos.x - this.lastPosition.x) > 0.1 || Math.abs(currentPos.y - this.lastPosition.y) > 0.1;

          // Update movement state based on translation status
          if (this.entity.inTranslation) {
            this.isMoving = true;
          } else {
            this.isMoving = false;
          }

          // Update last position
          this.lastPosition = { x: currentPos.x, y: currentPos.y };
        }

        animate() {
          this.updateMovementState();

          // Switch states based on movement
          const newState = this.isMoving ? "walk" : "idle";

          if (newState !== this.currentState) {
            this.currentState = newState;
            this.currentSprite = newState === "walk" ? this.walkSprite : this.idleSprite;
          }

          // Animate current sprite
          if (this.currentState === "idle") {
            this.currentSprite.animate("idle");
          } else {
            this.currentSprite.animate("walk");
          }
        }

        display() {
          this.currentSprite.display();
        }

        // Proxy methods for compatibility
        set offset(value) {
          this.idleSprite.offset = value;
          this.walkSprite.offset = value;
        }

        get offset() {
          return this.currentSprite.offset;
        }

        set speed(value) {
          this.idleSprite.speed = value;
          this.walkSprite.speed = value;
        }
      }

      class Body {
        constructor(entity, x, y) {
          this.world = entity.world;
          this.step = this.world.FPS.step;
          this.position = new Vector(x, y);
          this.next_position = new Vector(x, y);
          this.velocity = new Vector(0, 0);
          this.stepped_velocity = new Vector(0, 0);
          this.acceleration = new Vector(0, 0);
          this.drag = 0.98;
          this.size = {
            x: 16,
            y: 16,
          };
        }
        setSize(x, y) {
          this.size.x = x;
          this.size.y = y;
        }
        updateVelocity() {
          this.velocity.add(this.acceleration);
          this.velocity.mult(this.drag);
          this.stepped_velocity = this.velocity.copy();
          this.stepped_velocity.mult(this.step);
          this.next_position = this.position.copy();
          this.next_position.add(this.stepped_velocity);
          // reset acceleration
          this.acceleration.mult(0);
        }
        updatePosition() {
          this.position.add(this.stepped_velocity);
        }
        integration() {
          this.updateVelocity();
          this.updatePosition();
        }
        applyForce(force_vector) {
          this.acceleration.add(force_vector);
        }
      }

      class Vector {
        constructor(x, y) {
          this.x = x || 0;
          this.y = y || 0;
        }
        set(x, y) {
          this.x = x;
          this.y = y;
        }
        add(vector) {
          this.x += vector.x;
          this.y += vector.y;
        }
        sub(vector) {
          this.x -= vector.x;
          this.y -= vector.y;
        }
        mult(scalar) {
          this.x *= scalar;
          this.y *= scalar;
        }
        div(scalar) {
          this.x /= scalar;
          this.y /= scalar;
        }
        limit(limit_value) {
          if (this.mag() > limit_value) this.setMag(limit_value);
        }
        mag() {
          return Math.hypot(this.x, this.y);
        }
        setMag(new_mag) {
          if (this.mag() > 0) {
            this.normalize();
          } else {
            this.x = 1;
            this.y = 0;
          }
          this.mult(new_mag);
        }
        dist(vector) {
          return new Vector(this.x - vector.x, this.y - vector.y).mag();
        }
        normalize() {
          let mag = this.mag();
          if (mag > 0) {
            this.x /= mag;
            this.y /= mag;
          }
        }
        heading() {
          return Math.atan2(this.x, this.y);
        }
        setHeading(angle) {
          let mag = this.mag();
          this.x = Math.cos(angle) * mag;
          this.y = Math.sin(angle) * mag;
        }
        copy() {
          return new Vector(this.x, this.y);
        }
      }

      class Box {
        constructor(world, box_data) {
          this.world = world;
          this.ctx = world.ctx;
          this.c_ctx = world.c_ctx;
          this.box_data = box_data;
          this.resolution = box_data.resolution;
          this.image = world.assets.image[box_data.image].image;
        }
        display(x, y, width, height) {
          // background
          this.ctx.fillRect(x + 1, y + 1, width - 2, height - 2);
          // corners
          this.ctx.lineWidth = 2;
          let coners = [0, 2, 6, 8];
          for (let i = 0; i < 4; i++) {
            let pos_x = x + Math.floor(i % 2) * (width - this.resolution),
              pos_y = y + Math.floor(i / 2) * (height - this.resolution);
            let clip_x = Math.floor(i % 2) * (this.resolution * 2),
              clip_y = Math.floor(i / 2) * (this.resolution * 2);
            this.ctx.drawImage(
              this.image,
              clip_x,
              clip_y,
              this.resolution,
              this.resolution,
              pos_x,
              pos_y,
              this.resolution,
              this.resolution,
            );
          }
          let offset = this.resolution * 3;
          // top
          this.ctx.drawImage(
            this.image,
            8,
            0,
            this.resolution,
            this.resolution,
            x + 8,
            y,
            this.resolution + width - offset,
            this.resolution,
          );
          // bottom
          this.ctx.drawImage(
            this.image,
            8,
            16,
            this.resolution,
            this.resolution,
            x + 8,
            y + height - this.resolution,
            this.resolution + width - offset,
            this.resolution,
          );
          // left
          this.ctx.drawImage(
            this.image,
            0,
            8,
            this.resolution,
            this.resolution,
            x,
            y + 8,
            this.resolution,
            this.resolution + height - offset,
          );
          // right
          this.ctx.drawImage(
            this.image,
            16,
            8,
            this.resolution,
            this.resolution,
            x + width - this.resolution,
            y + this.resolution,
            this.resolution,
            this.resolution + height - offset,
          );
        }
      }
      // ----------
      // Diorama.js Engine
      // ----------
      class Diorama {
        constructor(parameters) {
          this.parameters = parameters;
          // Game and author's name
          this.game_info = {
            name: parameters.name || "Untitled",
            author: parameters.author || "Anonymous",
          };
          // canvas
          this.background_color = parameters.background_color || "#000";
          this.initCanvas(parameters);
          // Assets
          this.counter = 0;
          this.toLoad = parameters.assets.length;
          this.assets = {
            image: {},
            audio: {},
          };
          this.audio_muted = false;
          // keyboard event
          this.keys = {};
          // Scenes
          this.scenes = {};
          this.start_screen = parameters.start_screen || undefined;
          this.current_scene = "";
          // Bitmap font Data
          this.alphabet = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ?!:',.()<>[]";
          this.fonts = {};
          // Maps
          this.tile_size = parameters.tile_size || 16;
          this.tiles_data = {};
          if (parameters.tiles !== undefined) {
            parameters.tiles.map((tile) => {
              this.tiles_data[tile.id] = tile;
            });
          }
          this.mapsMax = parameters.maps.length;
          this.maps = {};
          if (parameters.maps !== undefined) {
            parameters.maps.map((map) => {
              this.maps[map.name] = map;
            });
          }
          // Box system
          this.boxes = {};
          // By default the current font is the first font you create
          this.currentFont = undefined;
          // Game loop Data
          this.FPS = {
            now: 0,
            delta: 0,
            last: Util.timeStamp(),
            step: 1 / (parameters.frame_rate || 60),
          };
          this.requestChange = {
            value: false,
            action: "",
          };
          this.main_loop = undefined;
        }
        // ---
        // Setup & Loading
        // ---
        ready() {
          this.loadAssets(this.parameters.assets);
        }
        initCanvas(parameters) {
          this.canvas = document.createElement("canvas");
          this.ctx = this.canvas.getContext("2d");
          this.W = this.canvas.width = parameters.width || 256;
          this.H = this.canvas.height = parameters.height || 256;
          this.scale = parameters.scale || 1;
          this.full = false;
          this.ctx.imageSmoothingEnabled = true;
          this.canvas.classList.add("crisp");
          document.body.appendChild(this.canvas);
          // cache canvas
          this.cache = document.createElement("canvas");
          this.c_ctx = this.cache.getContext("2d");
        }
        loader() {
          // increment loader
          this.counter += 1;

          // Clear background
          this.clear("#000000");

          // Calculate progress
          let progress = this.counter / this.toLoad;
          let progressPercent = Math.round(progress * 100);

          // Draw loading bar
          let padding = 40;
          let barWidth = this.W - padding * 2;
          let barHeight = 25;
          let x = padding;
          let y = this.H / 2; // Center vertically

          // Background of loading bar
          this.ctx.fillStyle = "#1a1a1a";
          this.ctx.fillRect(x, y, barWidth, barHeight);

          // Progress fill with golden gradient
          let gradient = this.ctx.createLinearGradient(x, y, x + barWidth, y);
          gradient.addColorStop(0, "#B8860B");
          gradient.addColorStop(0.5, "#DAA520");
          gradient.addColorStop(1, "#FFD700");

          this.ctx.fillStyle = gradient;
          this.ctx.fillRect(x, y, progress * barWidth, barHeight);

          // Border
          this.ctx.strokeStyle = "#FFD700";
          this.ctx.lineWidth = 2;
          this.ctx.strokeRect(x, y, barWidth, barHeight);

          // Loading text - centered above the bar
          this.ctx.font = "16px 'Pirata One', sans-serif";
          this.ctx.fillStyle = "#FFD700";
          this.ctx.textAlign = "center";
          this.ctx.textBaseline = "middle";

          this.ctx.fillText(`Loading Sea Adventure... ${progressPercent}%`, this.W / 2, y - 30);

          if (this.counter === this.toLoad) {
            console.log("🎮 All assets loaded successfully! Starting game...");
            this.launch();
          }
        }
        loadAssets(assets) {
          if (assets === undefined) console.log("Nothing to load");
          assets.map((obj) => this.checkAssets(obj));
        }
        checkAssets(obj) {
          let subject = obj;
          switch (obj.type) {
            case "img":
              let img = new Image();

              // Add timeout for image loading
              let imageTimeout = setTimeout(() => {
                console.warn(`Image loading timeout: ${obj.name} - ${obj.path}`);
                this.loader(); // Continue loading even if this image fails
              }, 10000); // 10 second timeout

              img.onload = () => {
                clearTimeout(imageTimeout);
                this.loader();
              };
              img.onerror = () => {
                clearTimeout(imageTimeout);
                console.error(`Failed to load image: ${obj.name} - ${obj.path}`);
                this.loader(); // Continue loading even if this image fails
              };

              // Set crossorigin for external images
              img.crossOrigin = "anonymous";
              img.src = obj.path;
              subject.image = img;
              this.assets.image[obj.name] = subject;
              break;

            case "audio":
              let audio = new Audio(obj.path);

              // Add timeout for audio loading
              let audioTimeout = setTimeout(() => {
                console.warn(`Audio loading timeout: ${obj.name} - ${obj.path}`);
                this.loader(); // Continue loading even if this audio fails
              }, 8000); // 8 second timeout

              let audioLoaded = false;
              const audioLoadHandler = () => {
                if (!audioLoaded) {
                  audioLoaded = true;
                  clearTimeout(audioTimeout);
                  this.loader();
                }
              };

              audio.addEventListener("canplaythrough", audioLoadHandler);
              audio.addEventListener("loadeddata", audioLoadHandler);

              audio.onerror = () => {
                if (!audioLoaded) {
                  audioLoaded = true;
                  clearTimeout(audioTimeout);
                  console.error(`Failed to load audio: ${obj.name} - ${obj.path}`);
                  this.loader(); // Continue loading even if this audio fails
                }
              };

              // Preload the audio
              audio.preload = "auto";
              audio.load();

              subject.audio = audio;
              this.assets.audio[obj.name] = subject;
              break;

            case undefined:
              console.log(obj.name, " doesn't have any type");
              break;
            default:
              console.log(obj.name, " has a none known type");
          }
        }
        launch() {
          this.eventSetup();
          this.initBoxes(this.parameters.boxes);
          this.initFonts(this.parameters.fonts);
          this.startScene(this.start_screen);
        }
        initBoxes(boxes_data) {
          if (boxes_data === undefined) return false;
          boxes_data.map((box) => {
            this.boxes[box.name] = new Box(this, box);
          });
        }
        drawBox(box_name, x, y, width, height) {
          // Check if box exists before trying to display it
          if (this.boxes[box_name]) {
            this.boxes[box_name].display(x, y, width, height);
          }
        }
        // ---
        // Font manager
        // ---
        setFont(font_name) {
          this.currentFont = font_name;
        }
        initFonts(fonts_data) {
          if (fonts_data === undefined && fonts_data.length > 0) return false;
          fonts_data.map((font) => {
            if (this.assets.image[font.image] === undefined) {
              console.log("can't load font, " + font.image + " doesn't exist");
              return false;
            }
            font.image = this.assets.image[font.image].image;
            this.fonts[font.name] = font;
          });
          // set current font to the first font !
          this.currentFont = Object.keys(this.fonts)[0];
        }
        write(text, x, y, justify, colorID) {
          if (this.currentFont === undefined) {
            console.log("No bitmap_font");
            return false;
          }
          if (typeof justify === "string") {
            switch (justify) {
              case "center":
                x -= (text.length * this.fonts[this.currentFont].size.x) / 2;
                break;
              case "right":
                x -= text.length * this.fonts[this.currentFont].size.x;
                break;
              default:
            }
            this.writeLine(text, x, y, colorID || 0);
          } else {
            this.writeParagraph(text, x, y, justify, colorID || 0);
          }
        }
        writeParagraph(text, x, y, justify, colorID) {
          let y_offset = 0,
            line_height = this.fonts[this.currentFont].size.y + 5,
            size_x = this.fonts[this.currentFont].size.x,
            words = text.split(" "),
            line = "";
          for (let i = 0; i < words.length; i++) {
            line += words[i] + " ";
            let nextword_width = 0,
              next_word = words[i + 1],
              line_length = line.length * size_x;
            next_word ? (nextword_width = next_word.length * size_x) : 0;
            if (line_length + nextword_width > justify) {
              this.writeLine(line, x, y + y_offset, 0, colorID);
              y_offset += line_height;
              line = "";
            } else {
              this.writeLine(line, x, y + y_offset, 0, colorID);
            }
          }
        }
        writeLine(text, x, y, colorID) {
          // write line
          let size_x = this.fonts[this.currentFont].size.x,
            size_y = this.fonts[this.currentFont].size.y,
            font_img = this.fonts[this.currentFont].image;
          for (let i = 0; i < text.length; i++) {
            let index = this.alphabet.indexOf(text.charAt(i)),
              clipX = size_x * index,
              posX = x + i * size_x;
            this.ctx.drawImage(font_img, clipX, colorID * size_y, size_x, size_y, posX, y, size_x, size_y);
          }
        }
        // -----------------
        // Events
        // -----------------
        eventSetup() {
          document.addEventListener("keydown", (event) => this.keyDown(event), false);
          document.addEventListener("keyup", (event) => this.keyUp(event), false);

          // Add mouse and touch events for mobile support
          this.canvas.addEventListener("click", (event) => this.mouseEvent(event), false);

          // Add simplified touch events for general canvas interaction
          this.canvas.addEventListener("touchstart", (event) => this.touchStart(event), false);
          this.canvas.addEventListener(
            "touchend",
            (event) => {
              event.preventDefault(); // Prevent double firing
              this.touchEnd(event);
            },
            false,
          );

          // Initialize control pad for mobile
          this.initControlPad();

          // Touch tracking variables
          this.touchStartX = 0;
          this.touchStartY = 0;
          this.touchEndX = 0;
          this.touchEndY = 0;
        }

        initControlPad() {
          const controlButtons = document.querySelectorAll(".control-button");

          // Initialize control pad visibility based on current device and scene
          updateControlPadVisibility(this.current_scene ? this.current_scene.name : "menu");

          controlButtons.forEach((button) => {
            const direction = button.getAttribute("data-direction");

            // Add touch events for mobile
            button.addEventListener("touchstart", (e) => {
              e.preventDefault();
              e.stopPropagation();
              this.handleControlPadInput(direction);
              button.classList.add("active");
            });

            button.addEventListener("touchend", (e) => {
              e.preventDefault();
              e.stopPropagation();
              button.classList.remove("active");
            });

            // Add mouse events for desktop testing (only if mobile device)
            if (isMobileDevice()) {
              button.addEventListener("mousedown", (e) => {
                e.preventDefault();
                e.stopPropagation();
                this.handleControlPadInput(direction);
                button.classList.add("active");
              });

              button.addEventListener("mouseup", (e) => {
                e.preventDefault();
                e.stopPropagation();
                button.classList.remove("active");
              });
            }

            // Prevent context menu on long press
            button.addEventListener("contextmenu", (e) => {
              e.preventDefault();
            });
          });
        }

        handleControlPadInput(direction) {
          if (!this.current_scene || this.current_scene.name !== "inGame") {
            return;
          }

          let moveX = 0,
            moveY = 0;

          switch (direction) {
            case "up":
              moveY = -1;
              break;
            case "down":
              moveY = 1;
              break;
            case "left":
              moveX = -1;
              break;
            case "right":
              moveX = 1;
              break;
          }

          if (moveX !== 0 || moveY !== 0) {
            console.log("Control pad input:", direction, moveX, moveY);
            this.current_scene.moveCats(moveX, moveY);
          }
        }
        keyDown(event) {
          event.preventDefault();
          this.keys[event.code] = true;
          // Only allow Arrow Keys and Space - remove F and M key handling
          this.current_scene.keyEvents(event);
        }
        keyUp(event) {
          event.preventDefault();
          this.keys[event.code] = false;
        }

        // Simplified touch event handlers
        touchStart(event) {
          event.preventDefault();
          const touch = event.touches[0];
          this.touchStartX = touch.clientX;
          this.touchStartY = touch.clientY;
        }

        touchEnd(event) {
          event.preventDefault();

          // Handle as click for menus and buttons when not in game
          if (!this.current_scene || this.current_scene.name !== "inGame") {
            // Create a synthetic mouse event from touch data for consistent handling
            const touch = event.changedTouches[0];
            const syntheticEvent = {
              clientX: touch.clientX,
              clientY: touch.clientY,
              changedTouches: event.changedTouches,
              touches: [], // Empty because touch has ended
              type: "touchend",
            };
            this.mouseEvent(syntheticEvent);
          }

          // Reset touch state
          this.touchStartX = 0;
          this.touchStartY = 0;
        }

        mouseEvent(event) {
          // Call mouseEvents method of current scene if it exists
          if (this.current_scene && typeof this.current_scene.mouseEvents === "function") {
            this.current_scene.mouseEvents(event);
          }
        }
        // ---
        // Scene Manager
        // ---
        startScene(scene_name) {
          // check if the scene exist
          if (this.scenes[scene_name] === undefined) return scene_name + " - doesn't exist";
          // request the change of scene if this.main_loop is active
          if (this.main_loop !== undefined) {
            this.requestChange.value = true;
            this.requestChange.action = scene_name;
            return false;
          }
          this.requestChange.value = false;
          this.requestChange.action = "";
          this.FPS.last = Util.timeStamp();
          this.current_scene = this.scenes[scene_name];

          // Update control pad visibility based on new scene
          updateControlPadVisibility(scene_name);

          // Update overlay systems based on new scene
          updateMenuOverlay();
          updateLevelsOverlay();

          // Handle music based on scene
          if (scene_name === "menu") {
            // Start menu music (waves) when entering menu
            setTimeout(() => {
              playMenuMusic();
            }, 100);
          }

          this.initScene();
          // does this scenes needs a gameloop ?
          if (this.current_scene.loop === true) {
            this.gameLoop();
          } else {
            this.mainRender();
          }
        }
        initScene() {
          if (this.current_scene.init_once) return false;
          this.current_scene.init();
        }
        addScene(scene) {
          // links this world to this scene
          scene.giveWorld(this);
          this.scenes[scene.name] = scene;
        }
        // ---
        // Main Loop
        // ---
        mainRender() {
          this.clear();
          this.current_scene.render();
        }
        loopCheck() {
          if (this.requestChange.value === false) {
            this.main_loop = requestAnimationFrame(() => this.gameLoop());
          } else {
            cancelAnimationFrame(this.main_loop);
            this.main_loop = undefined;
            this.startScene(this.requestChange.action);
          }
        }
        gameLoop() {
          this.FPS.now = Util.timeStamp();
          this.FPS.delta += Math.min(1, (this.FPS.now - this.FPS.last) / 1000);
          while (this.FPS.delta > this.FPS.step) {
            this.FPS.delta -= this.FPS.step;
            this.mainRender();
          }
          this.FPS.last = this.FPS.now;
          this.loopCheck();
        }
        // Basic functions
        soundLevel(volume) {
          for (let [k, v] of Object.entries(this.assets.audio)) {
            v.audio.volume = volume;
          }
        }
        mute() {
          this.audio_muted = !this.audio_muted;
          for (let [k, v] of Object.entries(this.assets.audio)) {
            v.audio.muted = this.audio_muted;
          }
        }
        clear(custom_color) {
          this.ctx.fillStyle = custom_color || this.background_color;
          this.ctx.fillRect(0, 0, this.W, this.H);
        }
        setScale() {
          this.canvas.style.width = this.W * this.scale + "px";
          this.canvas.style.height = this.H * this.scale + "px";
        }
        fullScreen() {
          this.full = !this.full;
          if (!this.full) {
            this.setScale();
          } else {
            this.canvas.style.width = "100%";
            this.canvas.style.height = "100%";
          }
        }
        // ---
        // Tile map
        // ---
        getTile(layer_id, x, y) {
          if (x < 0 || x > this.terrain.layers[layer_id].size.x - 1) return false;
          if (y < 0 || y > this.terrain.layers[layer_id].size.y - 1) return false;
          let tile = this.tiles_data[this.terrain.layers[layer_id].geometry[y][x]];
          if (tile === undefined) return false;
          return tile;
        }
        setTile(layer_id, x, y, tile_id) {
          if (x < 0 || x > this.terrain.layers[layer_id].size.x - 1) return false;
          if (y < 0 || y > this.terrain.layers[layer_id].size.y - 1) return false;
          this.terrain.layers[layer_id].geometry[y][x] = tile_id;
          return true;
        }
        findTile(layer_id, tile_id) {
          let layer = this.terrain.layers[layer_id];
          let result = [];
          for (let y = 0; y < layer.size.y; y++) {
            for (let x = 0; x < layer.size.x; x++) {
              let id = layer.geometry[y][x];
              if (id === tile_id) {
                result.push({ x: x, y: y });
              }
            }
          }
          return result;
        }
        initMap(map_name) {
          this.terrain = JSON.parse(JSON.stringify(this.maps[map_name]));
          // give size to layers
          for (var i = 0; i < this.terrain.layers.length; i++) {
            this.terrain.layers[i].size = {
              x: this.terrain.layers[i].geometry[0].length,
              y: this.terrain.layers[i].geometry.length,
            };
          }
          this.terrain.tileset = this.assets.image[this.maps[map_name].tileset].image;
          this.terrain.tileset_size = {
            width: this.terrain.tileset.width / this.tile_size,
            height: this.terrain.tileset.height / this.tile_size + 1,
          };
          this.terrain.layers.forEach((layer, index) => {
            this.marchingSquare(layer);
            this.bitMasking(layer);

            // create a cache for reducing draw call in the gameLoop
            this.terrainCache(layer);
            // prepare animated tiles
            layer.animated = [];
            for (var id in this.tiles_data) {
              if (this.tiles_data[id].animated === true) {
                let tiles = this.findTile(index, parseInt(id));
                layer.animated.push({
                  id: id,
                  spritesheet: this.assets.image[this.tiles_data[id].spritesheet].image,
                  positions: tiles,
                  current: 0,
                  steps: this.tiles_data[id].steps,
                  max_frame: this.assets.image[this.tiles_data[id].spritesheet].image.width / this.tile_size,
                });
              }
            }
          });
          this.clear("black");
        }
        terrainCache(layer) {
          layer.cache = {};
          let c = (layer.cache.c = document.createElement("canvas"));
          let ctx = (layer.cache.ctx = layer.cache.c.getContext("2d"));
          let W = (c.width = layer.size.x * this.tile_size),
            H = (c.height = layer.size.y * this.tile_size);
          // Draw on cache
          this.ctx.clearRect(0, 0, W, H);
          this.drawLayer(layer);
          ctx.drawImage(this.canvas, 0, 0);
          this.clear();
        }
        marchingSquare(layer) {
          layer.square = [];
          for (let y = 0; y < layer.size.y; y++) {
            for (let x = 0; x < layer.size.x; x++) {
              let p1 = 0,
                p2 = 0,
                p3 = 0,
                p4 = 0;

              if (y + 1 < layer.size.y && x + 1 < layer.size.x) {
                p1 = layer.geometry[y][x];
                p2 = layer.geometry[y][x + 1];
                p3 = layer.geometry[y + 1][x + 1];
                p4 = layer.geometry[y + 1][x];
              }
              let id = p1 * 8 + p2 * 4 + p3 * 2 + p4;
              layer.square.push(id);
            }
          }

          layer.square = Util.array2D(layer.square, layer.size.x);
        }
        bitMasking(layer) {
          layer.bitMask = [];
          for (let y = 0; y < layer.size.y; y++) {
            for (let x = 0; x < layer.size.x; x++) {
              let id = layer.geometry[y][x];
              let neighbor = [0, 0, 0, 0];
              if (y - 1 > -1) {
                if (id === layer.geometry[y - 1][x]) {
                  //top
                  neighbor[0] = 1;
                }
              } else {
                neighbor[0] = 1;
              }
              if (x - 1 > -1) {
                if (id === layer.geometry[y][x - 1]) {
                  // left
                  neighbor[1] = 1;
                }
              } else {
                neighbor[1] = 1;
              }
              if (x + 1 < layer.size.x) {
                if (id === layer.geometry[y][x + 1]) {
                  // right
                  neighbor[2] = 1;
                }
              } else {
                neighbor[2] = 1;
              }

              if (y + 1 < layer.size.y) {
                if (id === layer.geometry[y + 1][x]) {
                  //down
                  neighbor[3] = 1;
                }
              } else {
                neighbor[3] = 1;
              }
              id = 1 * neighbor[0] + 2 * neighbor[1] + 4 * neighbor[2] + 8 * neighbor[3];
              layer.bitMask.push(id);
            }
          }
          layer.bitMask = Util.array2D(layer.bitMask, layer.size.x);
        }
        renderMap() {
          this.terrain.layers.forEach((layer) => {
            this.ctx.drawImage(layer.cache.c, 0, 0);
            // draw animated layer
            layer.animated.forEach((tile) => {
              if (tile.current < tile.max_frame - 1) {
                tile.current += tile.steps;
              } else {
                tile.current = 0;
              }
              // render animated tiles
              tile.positions.forEach((position) => {
                let x = position.x * this.tile_size,
                  y = position.y * this.tile_size;

                // Add black border effect for exit tile
                if (tile.id == "8") {
                  // exit tile id
                  // Save context for effects
                  this.ctx.save();

                  // Force smooth rendering for this specific image
                  this.ctx.mozImageSmoothingEnabled = true;
                  this.ctx.webkitImageSmoothingEnabled = true;
                  this.ctx.msImageSmoothingEnabled = true;
                  this.ctx.imageSmoothingEnabled = true;
                  this.ctx.imageSmoothingQuality = "high";

                  // Calculate center and radius for circular border
                  let centerX = x + this.tile_size / 2;
                  let centerY = y + this.tile_size / 2;
                  let radius = this.tile_size / 2 - 1; // Slightly smaller to fit within tile

                  // Draw thick black border for circular logo
                  this.ctx.beginPath();
                  this.ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
                  this.ctx.strokeStyle = "black";
                  this.ctx.lineWidth = 4;
                  this.ctx.stroke();

                  // Draw the logo
                  this.ctx.drawImage(tile.spritesheet, x, y, this.tile_size, this.tile_size);

                  this.ctx.restore();
                } else if (tile.id == "17") {
                  // coin tile id - special handling for 32x32 frames
                  this.ctx.save();

                  // Force smooth rendering for coin
                  this.ctx.mozImageSmoothingEnabled = true;
                  this.ctx.webkitImageSmoothingEnabled = true;
                  this.ctx.msImageSmoothingEnabled = true;
                  this.ctx.imageSmoothingEnabled = true;
                  this.ctx.imageSmoothingQuality = "high";

                  // Ensure frame index is always valid (0-7)
                  let frameIndex = Math.floor(tile.current) % 8;
                  if (frameIndex < 0) frameIndex = 0;
                  if (frameIndex > 7) frameIndex = 7;

                  // Draw the coin with correct frame size (32x32 frames)
                  this.ctx.drawImage(
                    tile.spritesheet,
                    frameIndex * 32, // 32px per frame
                    0,
                    32, // source width
                    32, // source height
                    x,
                    y,
                    this.tile_size, // scale to game tile size (16x16)
                    this.tile_size,
                  );

                  this.ctx.restore();
                } else {
                  // Normal animated tile rendering
                  this.ctx.drawImage(
                    tile.spritesheet,
                    Math.floor(tile.current) * this.tile_size,
                    0,
                    this.tile_size,
                    this.tile_size,
                    x,
                    y,
                    this.tile_size,
                    this.tile_size,
                  );
                }
              });
            });
          });
        }
        drawMap() {
          this.terrain.layers.forEach((layer) => {
            this.drawLayer(layer);
          });
        }
        drawLayer(layer) {
          for (let y = 0; y < layer.size.y; y++) {
            for (let x = 0; x < layer.size.x; x++) {
              // ID of the tile
              let id = layer.geometry[y][x];
              // Don't draw invisible tiles
              // Position of the tile :)
              let positionX = x * this.tile_size + layer.offset.x,
                positionY = y * this.tile_size + layer.offset.y;
              let sourceX = Math.floor(id % this.terrain.tileset_size.width) * this.tile_size,
                sourceY = Math.floor(id / this.terrain.tileset_size.width) * this.tile_size;
              if (this.tiles_data[id] && this.tiles_data[id].look === "bitmask") {
                sourceX = Math.floor(layer.bitMask[y][x]) * this.tile_size;
                sourceY = this.tiles_data[id].line * this.tile_size;
              }

              if (layer.look === "square") {
                if (layer.square[y][x] === 0) continue;
                positionX += this.tile_size / 2;
                positionY += this.tile_size / 2;
                sourceX = Math.floor(layer.square[y][x] % 16) * 16;
                sourceY = 7 * this.tile_size;
              }

              if (this.tiles_data[id] && this.tiles_data[id].animated === true) {
                // hide animated sprites on the cache
                continue;
              }

              // render tile

              this.ctx.drawImage(
                this.terrain.tileset,
                sourceX,
                sourceY,
                this.tile_size,
                this.tile_size,
                positionX,
                positionY,
                this.tile_size,
                this.tile_size,
              );
            }
          }
        }
      }
      let parameters = {
        name: "Copycat",
        start_screen: "menu",
        background_color: "#223d8c",
        width: 256,
        height: 256,
        tile_size: 16,
        assets: [
          // Images
          {
            type: "img",
            name: "pirate_captain_idle",
            path: "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/6d6bc837-fad6-47ee-91cd-cdfeb472750a/Pirate%20Captain%20%28Idle%29-d3UCZVEll9XXrrTtsHbdqzhQfDmEqT.png?AxwH",
          },
          {
            type: "img",
            name: "pirate_captain_walk",
            path: "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/6d6bc837-fad6-47ee-91cd-cdfeb472750a/Pirate%20Captain%20%28Walk%29-o9HZz1cq8sTTV1GFaSKi7t9PSOrFLf.png?kxws",
          },
          {
            type: "img",
            name: "spawn_effect",
            path: "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/6d6bc837-fad6-47ee-91cd-cdfeb472750a/spawn-effect-XPG27cMg6ufUTII9XanTrw8NQ26b8W.png?vCTc",
          },
          {
            type: "img",
            name: "water_splash",
            path: "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/6d6bc837-fad6-47ee-91cd-cdfeb472750a/water-splash-32OCm8L74yn7LRBAAUWO2kx8CY6vnz.png?vErF",
          },
          {
            type: "img",
            name: "shadow",
            path: "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/6d6bc837-fad6-47ee-91cd-cdfeb472750a/shadow-EW81iPoAS8NMoWBtaX1smDKBPFeEJ0.png?KUK4",
          },
          {
            type: "img",
            name: "menu_background_island",
            path: "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/6d6bc837-fad6-47ee-91cd-cdfeb472750a/The%20Open-Sea%20%289%29-ldKqKPyTn8Ki18H1iohz4CMPw1PFOV.png?oG0m",
          },
          {
            type: "img",
            name: "demo_tileset",
            path: "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/6d6bc837-fad6-47ee-91cd-cdfeb472750a/demo-tileset-XdRc2ksEo7K0NQP8MMtzH0hcUz3RqS.png?Vagi",
          },
          {
            type: "img",
            name: "exit",
            path: "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/6d6bc837-fad6-47ee-91cd-cdfeb472750a/opensea-XTtQ5WP96D0Xj4Z90Q6rdQJbY5w1eR.png?CSSG",
          },
          {
            type: "img",
            name: "water_sprite",
            path: "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/6d6bc837-fad6-47ee-91cd-cdfeb472750a/water-sprite-WK70krNHiVKN27EYGHmhulFC6ADqA7.png?BkTF",
          },
          {
            type: "img",
            name: "dust_effect",
            path: "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/6d6bc837-fad6-47ee-91cd-cdfeb472750a/dust-xu96vCZnezAnvBdOGUECteaPerPzhR.png?h3rX",
          },
          {
            type: "img",
            name: "coin_sprite",
            path: "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/6d6bc837-fad6-47ee-91cd-cdfeb472750a/coin-p9L1iH5QesSoxJnawnk44d0gGZ5sJ1.png?kPeD",
          },
          {
            type: "img",
            name: "surrender_button",
            path: "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/6d6bc837-fad6-47ee-91cd-cdfeb472750a/redbutton-m50kIc64V6BJZuyeQESCLuOxNHTJcg.png?lhaA",
          },
          // Audio
          {
            type: "audio",
            name: "jingle",
            path: "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/6d6bc837-fad6-47ee-91cd-cdfeb472750a/waves-bWs1OMPYRpODjTOSXkwhP9CNBPVEMm.mp3?01R0",
          },
          {
            type: "audio",
            name: "selection",
            path: "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/6d6bc837-fad6-47ee-91cd-cdfeb472750a/collectcoin-6075-rjrkxbNHSsH3QzqnurDamQrx3K87pQ.mp3?vsYo",
          },
          {
            type: "audio",
            name: "coin_collect",
            path: "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/6d6bc837-fad6-47ee-91cd-cdfeb472750a/collectcoin-6075-rjrkxbNHSsH3QzqnurDamQrx3K87pQ.mp3?vsYo",
          },
          {
            type: "audio",
            name: "eboulement",
            path: "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/6d6bc837-fad6-47ee-91cd-cdfeb472750a/game-over-eXhbU57XcekmZPntLzuPIn06iXDjbN.mp3?jVoy",
          },
          {
            type: "audio",
            name: "splash",
            path: "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/6d6bc837-fad6-47ee-91cd-cdfeb472750a/splash-SOkXu7Zfm7m9DomHSWtNm6we2H9Rwq.mp3?7gjD",
          },
          {
            type: "audio",
            name: "pirate1",
            path: "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/6d6bc837-fad6-47ee-91cd-cdfeb472750a/pirate1-6BrzaKv8igJ1h5IJa3phuLnB0fCX6V.mp3?LPuj",
          },

          // No bitmap fonts needed - using Google Fonts instead
        ],
        fonts: [
          // All fonts now use Google Fonts (Pirata One, etc.)
        ],
        // box system
        boxes: [],
        tiles: [
          { name: "empty", id: 0, collision: false, visibility: false },
          { name: "water", id: 1, collision: false, look: "square", line: 7 },
          { name: "shores", id: 2, collision: false, look: "bitmask", line: 6 },
          { name: "ground", id: 3, collision: false, look: "bitmask", line: 1 },
          { name: "wall", id: 4, collision: true, look: "bitmask", line: 2 },
          { name: "fence", id: 11, collision: true, look: "bitmask", line: 4 },
          { name: "bush", id: 5, collision: true },
          { name: "ice", id: 6, collision: false, look: "bitmask", line: 3 },
          { name: "spawn", id: 7, collision: false },
          {
            name: "exit",
            id: 8,
            collision: false,
            animated: true,
            spritesheet: "exit",
            steps: 0.4,
          },
          {
            name: "waves",
            id: 16,
            collision: false,
            animated: true,
            spritesheet: "water_sprite",
            steps: 0.2,
          },
          { name: "trap", id: 9, collision: false },
          { name: "hole", id: 10, collision: true },
          // arrows
          { name: "arrowLeft", id: 12, collision: false },
          { name: "arrowUp", id: 13, collision: false },
          { name: "arrowRight", id: 14, collision: false },
          { name: "arrowDown", id: 15, collision: false },
          {
            name: "coin",
            id: 17,
            collision: false,
            animated: true,
            spritesheet: "coin_sprite",
            steps: 0.08,
          },
        ],
        maps: [
          // map 1
          {
            name: "map_1",
            tileset: "demo_tileset",
            // ground
            layers: [
              // ground layer
              {
                name: "ground",
                offset: {
                  x: 0,
                  y: 4,
                },
                geometry: [
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 3, 3, 0, 0, 0, 3, 3, 3, 3, 3, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0],
                  [0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                ],
              },
              // ice / arrows / layer
              {
                name: "onGround",
                offset: {
                  x: 0,
                  y: 0,
                },
                geometry: [
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 11, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 11, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 8, 5, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 5, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                ],
              },
              // wall layer
              {
                name: "wall",
                offset: {
                  x: 0,
                  y: 0,
                },
                geometry: [
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                ],
              },
            ],
          },
          // map 2
          {
            name: "map_2",
            tileset: "demo_tileset",
            // ground
            layers: [
              // ground layer
              {
                name: "ground",
                offset: {
                  x: 0,
                  y: 4,
                },
                geometry: [
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 3, 3, 3, 3, 3, 0, 0, 3, 3, 3, 3, 3, 0, 0],
                  [0, 0, 3, 3, 3, 3, 3, 0, 0, 3, 3, 3, 3, 3, 0, 0],
                  [0, 0, 3, 3, 3, 3, 3, 0, 0, 3, 3, 3, 3, 3, 0, 0],
                  [0, 0, 3, 3, 3, 3, 3, 0, 0, 3, 3, 3, 3, 3, 0, 0],
                  [0, 0, 3, 3, 3, 3, 3, 0, 0, 3, 3, 3, 3, 3, 0, 0],
                  [0, 0, 3, 3, 3, 3, 3, 0, 0, 3, 3, 3, 3, 3, 0, 0],
                  [0, 0, 3, 3, 3, 3, 3, 0, 0, 3, 3, 3, 3, 3, 0, 0],
                  [0, 0, 3, 3, 3, 3, 3, 0, 0, 3, 3, 3, 3, 3, 0, 0],
                  [0, 0, 3, 3, 3, 3, 3, 0, 0, 3, 3, 3, 3, 3, 0, 0],
                  [0, 0, 3, 3, 3, 3, 3, 0, 0, 3, 3, 3, 3, 3, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                ],
              },
              // ice / arrows / layer
              {
                name: "onGround",
                offset: {
                  x: 0,
                  y: 0,
                },
                geometry: [
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 11, 11, 11, 11, 11, 0, 0, 11, 11, 11, 11, 11, 0, 0],
                  [0, 0, 11, 0, 0, 0, 11, 0, 0, 11, 0, 0, 17, 11, 0, 0],
                  [0, 0, 11, 0, 8, 0, 11, 0, 0, 11, 0, 8, 0, 11, 0, 0],
                  [0, 0, 11, 0, 0, 0, 11, 0, 0, 11, 0, 0, 0, 11, 0, 0],
                  [0, 0, 11, 17, 0, 0, 11, 0, 0, 11, 0, 0, 0, 11, 0, 0],
                  [0, 0, 11, 4, 4, 0, 11, 0, 0, 11, 0, 0, 0, 11, 0, 0],
                  [0, 0, 11, 0, 0, 0, 11, 0, 0, 11, 0, 4, 4, 11, 0, 0],
                  [0, 0, 11, 0, 0, 0, 11, 0, 0, 11, 0, 0, 0, 11, 0, 0],
                  [0, 0, 11, 0, 7, 0, 11, 0, 0, 11, 0, 7, 0, 11, 0, 0],
                  [0, 0, 11, 11, 11, 11, 11, 0, 0, 11, 11, 11, 11, 11, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                ],
              },
              // wall layer
            ],
          },
          {
            name: "map_3",
            tileset: "demo_tileset",
            // ground
            layers: [
              // ground layer
              {
                name: "ground",
                offset: {
                  x: 0,
                  y: 4,
                },
                geometry: [
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 0, 0, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 0, 0, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 0, 0, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 0, 0, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 0, 0, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 0, 0, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 0, 0, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 0, 0, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 0, 0, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 0, 0, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                ],
              },
              // ice / arrows / layer
              {
                name: "onGround",
                offset: {
                  x: 0,
                  y: 0,
                },
                geometry: [
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0],
                  [0, 0, 4, 0, 0, 0, 17, 0, 0, 17, 0, 0, 0, 4, 0, 0],
                  [0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0],
                  [0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 4, 0, 0],
                  [0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0],
                  [0, 0, 4, 8, 0, 0, 0, 0, 0, 0, 5, 0, 0, 4, 0, 0],
                  [0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0],
                  [0, 0, 4, 11, 11, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0],
                  [0, 0, 4, 7, 0, 0, 0, 0, 0, 0, 0, 7, 0, 4, 0, 0],
                  [0, 0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                ],
              },
              // wall layer
            ],
          },

          {
            name: "map_4",
            tileset: "demo_tileset",
            // ground
            layers: [
              // ground layer
              {
                name: "ground",
                offset: {
                  x: 0,
                  y: 4,
                },
                geometry: [
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0],
                  [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0],
                  [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0],
                  [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0],
                  [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0],
                  [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0],
                  [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0],
                  [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0],
                  [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0],
                  [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0],
                  [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0],
                  [0, 0, 0, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                ],
              },
              // ice / arrows / layer
              {
                name: "onGround",
                offset: {
                  x: 0,
                  y: 0,
                },
                geometry: [
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 11, 11, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 17, 11, 0, 0, 0],
                  [0, 0, 0, 0, 11, 11, 11, 0, 0, 0, 11, 0, 11, 0, 0, 0],
                  [0, 0, 0, 0, 11, 0, 11, 0, 0, 0, 11, 0, 11, 0, 0, 0],
                  [0, 0, 0, 0, 11, 0, 11, 0, 0, 0, 11, 9, 11, 0, 0, 0],
                  [0, 0, 0, 0, 11, 8, 11, 0, 0, 0, 11, 8, 11, 0, 0, 0],
                  [0, 0, 0, 0, 11, 0, 11, 0, 0, 0, 11, 7, 11, 0, 0, 0],
                  [0, 0, 0, 0, 11, 0, 11, 0, 0, 0, 11, 0, 11, 0, 0, 0],
                  [0, 0, 0, 0, 11, 0, 11, 5, 0, 0, 11, 11, 11, 0, 0, 0],
                  [0, 0, 0, 0, 11, 7, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 11, 11, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                ],
              }, // wall layer
            ],
          },
          {
            name: "map_5",
            tileset: "demo_tileset",
            // ground
            layers: [
              // ground layer
              {
                name: "ground",
                offset: {
                  x: 0,
                  y: 4,
                },
                geometry: [
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                ],
              },
              // ice / arrows / layer
              {
                name: "onGround",
                offset: {
                  x: 0,
                  y: 0,
                },
                geometry: [
                  [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
                  [4, 0, 5, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
                  [4, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
                  [4, 4, 4, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 4, 4, 4],
                  [4, 4, 4, 6, 6, 6, 6, 6, 6, 6, 17, 6, 6, 4, 4, 4],
                  [4, 4, 4, 6, 5, 6, 6, 6, 6, 6, 6, 6, 6, 4, 4, 4],
                  [4, 4, 4, 6, 6, 6, 6, 6, 6, 6, 6, 5, 6, 4, 4, 4],
                  [4, 4, 4, 6, 6, 6, 6, 6, 4, 6, 6, 6, 6, 8, 4, 4],
                  [4, 4, 4, 6, 6, 4, 6, 6, 4, 6, 4, 4, 6, 4, 4, 4],
                  [4, 4, 4, 4, 6, 6, 6, 6, 4, 6, 6, 6, 6, 4, 4, 4],
                  [4, 4, 4, 6, 6, 6, 6, 6, 6, 17, 6, 6, 6, 4, 4, 4],
                  [4, 4, 4, 6, 6, 6, 5, 6, 6, 6, 6, 0, 0, 4, 4, 4],
                  [4, 4, 4, 6, 6, 6, 6, 6, 6, 6, 6, 0, 7, 4, 4, 4],
                  [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 4],
                  [4, 5, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 4],
                  [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
                ],
              }, // wall layer
            ],
          },

          {
            name: "map_6",
            tileset: "demo_tileset",
            // ground
            layers: [
              // ground layer
              {
                name: "ground",
                offset: {
                  x: 0,
                  y: 4,
                },
                geometry: [
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                ],
              },
              // ice / arrows / layer
              {
                name: "onGround",
                offset: {
                  x: 0,
                  y: 0,
                },
                geometry: [
                  [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
                  [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
                  [4, 4, 4, 6, 6, 14, 0, 6, 6, 6, 6, 15, 4, 4, 4, 4],
                  [4, 4, 4, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 4, 4, 4],
                  [4, 4, 4, 6, 6, 6, 8, 6, 6, 6, 4, 6, 17, 4, 4, 4],
                  [4, 4, 4, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 4, 4, 4],
                  [4, 4, 4, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 4, 4, 4],
                  [4, 4, 4, 6, 6, 6, 6, 6, 6, 6, 6, 7, 6, 4, 4, 4],
                  [4, 4, 4, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 4, 4, 4],
                  [4, 4, 4, 6, 6, 14, 6, 6, 6, 6, 6, 6, 4, 4, 4, 4],
                  [4, 4, 4, 6, 6, 6, 6, 6, 6, 6, 0, 6, 4, 4, 4, 4],
                  [4, 4, 4, 6, 6, 0, 6, 6, 6, 6, 6, 6, 6, 4, 4, 4],
                  [4, 4, 4, 6, 6, 6, 6, 6, 6, 17, 6, 8, 13, 4, 4, 4],
                  [4, 4, 4, 6, 6, 6, 7, 6, 6, 6, 6, 6, 6, 4, 4, 4],
                  [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
                  [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
                ],
              }, // wall layer
            ],
          },

          {
            name: "map_7",
            tileset: "demo_tileset",
            // ground
            layers: [
              // ground layer
              {
                name: "ground",
                offset: {
                  x: 0,
                  y: 4,
                },
                geometry: [
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                ],
              },
              // ice / arrows / layer - MAZE LAYOUT
              {
                name: "onGround",
                offset: {
                  x: 0,
                  y: 0,
                },
                geometry: [
                  [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
                  [4, 17, 6, 0, 6, 6, 6, 6, 4, 6, 4, 6, 6, 6, 8, 4],
                  [4, 6, 6, 6, 6, 6, 6, 6, 6, 6, 4, 6, 4, 4, 6, 4],
                  [4, 6, 4, 4, 6, 4, 6, 6, 4, 6, 6, 6, 4, 17, 6, 4],
                  [4, 6, 6, 6, 6, 4, 4, 4, 4, 4, 4, 6, 4, 6, 4, 4],
                  [4, 4, 4, 6, 4, 4, 6, 6, 6, 6, 4, 6, 6, 6, 4, 4],
                  [4, 6, 6, 6, 4, 6, 6, 4, 6, 4, 4, 4, 6, 4, 4, 4],
                  [4, 6, 4, 4, 4, 6, 4, 4, 6, 6, 6, 6, 6, 6, 5, 4],
                  [4, 6, 6, 6, 6, 6, 4, 6, 6, 4, 6, 4, 4, 4, 6, 4],
                  [4, 4, 6, 4, 4, 4, 4, 6, 4, 4, 6, 6, 6, 6, 6, 4],
                  [4, 5, 6, 6, 6, 6, 6, 6, 4, 17, 6, 4, 6, 4, 6, 4],
                  [4, 6, 4, 6, 4, 4, 4, 6, 4, 6, 6, 4, 6, 6, 6, 4],
                  [4, 6, 4, 6, 6, 6, 6, 6, 6, 6, 4, 4, 4, 6, 4, 4],
                  [4, 6, 4, 4, 4, 6, 4, 4, 4, 6, 6, 6, 5, 6, 7, 4],
                  [4, 6, 6, 6, 6, 6, 6, 6, 6, 6, 4, 4, 6, 4, 4, 4],
                  [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
                ],
              }, // wall layer
            ],
          },

          {
            name: "map_8",
            tileset: "demo_tileset",
            // ground - Advanced Two Pirates Challenge
            layers: [
              // ground layer
              {
                name: "ground",
                offset: {
                  x: 0,
                  y: 4,
                },
                geometry: [
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 0],
                  [0, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 0],
                  [0, 3, 3, 3, 3, 0, 0, 3, 3, 0, 0, 3, 3, 3, 3, 0],
                  [0, 3, 3, 3, 3, 0, 0, 3, 3, 0, 0, 3, 3, 3, 3, 0],
                  [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0],
                  [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0],
                  [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0],
                  [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0],
                  [0, 3, 3, 3, 3, 0, 0, 3, 3, 0, 0, 3, 3, 3, 3, 0],
                  [0, 3, 3, 3, 3, 0, 0, 3, 3, 0, 0, 3, 3, 3, 3, 0],
                  [0, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 0],
                  [0, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                ],
              },
              // Complex multi-island layout with bridges and obstacles
              {
                name: "onGround",
                offset: {
                  x: 0,
                  y: 0,
                },
                geometry: [
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 11, 11, 11, 11, 0, 0, 0, 0, 0, 0, 11, 11, 11, 11, 0],
                  [0, 11, 0, 5, 11, 0, 0, 0, 0, 0, 0, 0, 17, 0, 11, 0],
                  [0, 11, 0, 7, 11, 0, 0, 11, 11, 0, 0, 0, 5, 0, 11, 0],
                  [0, 11, 17, 0, 11, 0, 0, 11, 11, 0, 0, 0, 0, 8, 11, 0],
                  [0, 0, 0, 0, 11, 11, 11, 11, 11, 11, 11, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 5, 0, 11, 11, 17, 5, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 11, 11, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 5, 17, 11, 11, 0, 5, 0, 0, 0, 0, 0],
                  [0, 11, 11, 0, 11, 0, 0, 11, 11, 0, 0, 11, 0, 11, 11, 0],
                  [0, 11, 8, 0, 11, 0, 0, 11, 11, 0, 0, 11, 0, 7, 11, 0],
                  [0, 11, 5, 0, 11, 0, 0, 0, 0, 0, 0, 11, 0, 17, 11, 0],
                  [0, 11, 11, 11, 11, 0, 0, 0, 0, 0, 0, 11, 11, 11, 11, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                ],
              }, // wall layer
            ],
          },

          {
            name: "map_9",
            tileset: "demo_tileset",
            // Water Maze Challenge - Single Pirate
            layers: [
              // ground layer - crear un laberinto con caminos de tierra rodeados de agua
              {
                name: "ground",
                offset: {
                  x: 0,
                  y: 4,
                },
                geometry: [
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 3, 0, 3, 3, 0, 0, 3, 3, 3, 3, 0, 0, 3, 0, 0],
                  [0, 3, 0, 0, 3, 0, 0, 3, 0, 0, 3, 0, 0, 3, 0, 0],
                  [0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 3, 3, 3, 3, 3, 0],
                  [0, 0, 3, 0, 0, 3, 0, 0, 3, 0, 0, 3, 0, 0, 3, 0],
                  [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 3, 0],
                  [0, 0, 3, 0, 0, 3, 3, 3, 3, 0, 0, 3, 0, 0, 3, 0],
                  [0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 3, 3, 3, 3, 0],
                  [0, 3, 0, 0, 3, 0, 0, 0, 0, 3, 0, 0, 3, 0, 0, 0],
                  [0, 3, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0],
                  [0, 3, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0],
                  [0, 3, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0],
                  [0, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                ],
              },
              // coins y spawn/exit - distribuir monedas estratégicamente por el laberinto
              {
                name: "onGround",
                offset: {
                  x: 0,
                  y: 0,
                },
                geometry: [
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 7, 0, 0, 0, 0, 0, 17, 0, 0, 0, 0, 0, 17, 0, 0],
                  [0, 0, 0, 0, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 17, 0, 0, 0, 0, 0, 17, 0, 0, 0, 0],
                  [0, 0, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 17, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 17, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 17, 0, 0, 0, 0, 0, 0, 0, 17, 0, 0, 0],
                  [0, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 8, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                ],
              }, // coins layer
            ],
          },

          {
            name: "map_10",
            tileset: "demo_tileset",
            // Horizontal Twin Pirate Challenge - Ice & Earth Adventure
            layers: [
              // ground layer - todo terreno sólido, sin agua (basado en map_6)
              {
                name: "ground",
                offset: {
                  x: 0,
                  y: 4,
                },
                geometry: [
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                ],
              },
              // rutas horizontales separadas con obstáculos (NIVEL EXTREMO)
              {
                name: "onGround",
                offset: {
                  x: 0,
                  y: 0,
                },
                geometry: [
                  [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
                  [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
                  [4, 7, 6, 6, 5, 6, 6, 6, 11, 6, 6, 5, 6, 6, 6, 4],
                  [4, 6, 6, 6, 17, 6, 5, 6, 6, 6, 11, 6, 6, 5, 6, 4],
                  [4, 5, 6, 6, 6, 11, 6, 6, 6, 6, 6, 6, 11, 6, 6, 4],
                  [4, 6, 6, 5, 6, 6, 6, 11, 6, 6, 5, 6, 6, 8, 6, 4],
                  [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
                  [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
                  [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
                  [4, 6, 6, 11, 6, 6, 5, 6, 6, 6, 11, 6, 6, 5, 6, 4],
                  [4, 17, 6, 6, 6, 11, 6, 6, 5, 6, 6, 6, 11, 6, 6, 4],
                  [4, 8, 5, 6, 6, 6, 6, 17, 6, 5, 6, 6, 6, 6, 7, 4],
                  [4, 6, 6, 6, 11, 6, 6, 5, 6, 6, 6, 11, 6, 6, 5, 4],
                  [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
                  [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
                  [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
                ],
              }, // obstacles layer
            ],
          },

          {
            name: "map_11",
            tileset: "demo_tileset",
            // Ice Arena - Mapa vacío con solo bordes y nieve
            layers: [
              // ground layer - todo terreno sólido
              {
                name: "ground",
                offset: {
                  x: 0,
                  y: 4,
                },
                geometry: [
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 0, 3, 3, 0, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 0, 3, 0, 0, 0, 3, 0, 3, 0, 3, 3],
                  [3, 3, 3, 3, 3, 0, 3, 0, 0, 0, 3, 0, 3, 0, 3, 3],
                  [3, 3, 3, 3, 3, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                ],
              },
              // Arena de hielo - solo bordes y nieve
              {
                name: "onGround",
                offset: {
                  x: 0,
                  y: 0,
                },
                geometry: [
                  [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
                  [4, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 4],
                  [4, 7, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 4],
                  [4, 6, 6, 15, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 4],
                  [4, 6, 6, 6, 6, 0, 0, 0, 0, 6, 6, 8, 6, 6, 6, 4],
                  [4, 6, 6, 6, 6, 0, 5, 5, 0, 6, 6, 6, 6, 6, 6, 4],
                  [4, 6, 6, 6, 6, 0, 0, 0, 0, 6, 6, 6, 6, 6, 6, 4],
                  [4, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 4],
                  [4, 6, 6, 6, 6, 6, 6, 5, 6, 6, 6, 6, 6, 6, 6, 4],
                  [4, 6, 6, 6, 6, 0, 6, 0, 0, 0, 5, 6, 5, 6, 6, 4],
                  [4, 6, 6, 5, 6, 0, 6, 0, 0, 0, 5, 6, 5, 6, 6, 4],
                  [4, 6, 6, 6, 6, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 4],
                  [4, 5, 6, 6, 6, 6, 6, 6, 6, 6, 5, 6, 5, 5, 5, 4],
                  [4, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 13, 6, 6, 6, 4],
                  [4, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 4],
                  [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
                ],
              }, // ice arena layer
            ],
          },

          {
            name: "map_12",
            tileset: "demo_tileset",
            // Team Rocket Hideout Style - Ice sliding puzzle maze with single pirate
            layers: [
              // ground layer - todo terreno sólido
              {
                name: "ground",
                offset: {
                  x: 0,
                  y: 4,
                },
                geometry: [
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                ],
              },
              // ice maze layer - Team Rocket style con impulsadores direccionales
              {
                name: "onGround",
                offset: {
                  x: 0,
                  y: 0,
                },
                geometry: [
                  [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
                  [4, 7, 6, 14, 6, 6, 13, 6, 6, 14, 6, 6, 14, 17, 6, 4],
                  [4, 6, 4, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 12, 4, 4],
                  [4, 6, 14, 6, 6, 15, 6, 6, 13, 6, 6, 4, 6, 6, 6, 4],
                  [4, 4, 6, 6, 4, 6, 6, 6, 6, 6, 6, 6, 6, 6, 4, 4],
                  [4, 6, 6, 13, 6, 17, 6, 14, 6, 6, 6, 15, 6, 15, 6, 4],
                  [4, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 4],
                  [4, 14, 6, 6, 6, 6, 4, 6, 4, 4, 6, 6, 6, 6, 13, 4],
                  [4, 6, 6, 6, 12, 6, 6, 6, 15, 6, 12, 6, 6, 6, 6, 4],
                  [4, 6, 4, 6, 6, 6, 6, 6, 6, 6, 6, 6, 4, 6, 6, 4],
                  [4, 13, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 12, 4],
                  [4, 6, 6, 6, 6, 12, 6, 6, 6, 13, 6, 6, 6, 6, 6, 4],
                  [4, 6, 6, 15, 6, 6, 6, 6, 6, 6, 6, 14, 6, 17, 6, 4],
                  [4, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 4, 4, 4],
                  [4, 6, 6, 6, 6, 6, 13, 6, 6, 14, 6, 6, 6, 6, 8, 4],
                  [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
                ],
              }, // ice maze layer
            ],
          },

          {
            name: "map_13",
            tileset: "demo_tileset",
            // Twin Coordination Challenge - Rediseñado para ser completable
            layers: [
              // ground layer - terreno sólido para coordinación
              {
                name: "ground",
                offset: {
                  x: 0,
                  y: 4,
                },
                geometry: [
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                ],
              },
              // Coordinación simplificada pero desafiante
              {
                name: "onGround",
                offset: {
                  x: 0,
                  y: 0,
                },
                geometry: [
                  [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
                  [4, 7, 0, 0, 5, 0, 0, 0, 0, 0, 5, 0, 0, 0, 8, 4],
                  [4, 4, 4, 0, 4, 4, 4, 4, 4, 4, 4, 0, 4, 4, 4, 4],
                  [4, 0, 0, 0, 0, 17, 0, 0, 0, 17, 5, 0, 0, 0, 0, 4],
                  [4, 0, 4, 5, 4, 4, 4, 0, 4, 4, 4, 5, 4, 0, 4, 4],
                  [4, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 4],
                  [4, 4, 4, 0, 4, 0, 4, 4, 4, 0, 4, 0, 4, 4, 4, 4],
                  [4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4],
                  [4, 4, 4, 0, 4, 0, 4, 4, 4, 0, 4, 0, 4, 4, 4, 4],
                  [4, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 4],
                  [4, 0, 4, 5, 4, 4, 4, 0, 4, 4, 4, 5, 4, 0, 4, 4],
                  [4, 0, 0, 0, 0, 17, 0, 0, 0, 17, 5, 0, 0, 0, 0, 4],
                  [4, 4, 4, 0, 4, 4, 4, 4, 4, 4, 4, 0, 4, 4, 4, 4],
                  [4, 7, 0, 0, 5, 0, 0, 0, 0, 0, 5, 0, 0, 0, 8, 4],
                  [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
                  [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
                ],
              }, // twin coordination layer
            ],
          },
        ],
      };

      parameters.maps.forEach((map) => {
        new_layer = {};
        new_layer.name = "water";
        new_layer.look = "square";
        new_layer.offset = { x: 0, y: 8 };
        new_layer.geometry = Array(16)
          .fill()
          .map(() => Array(16).fill(0));
        map.layers.unshift(new_layer);
        //
        new_layer = {};
        new_layer.name = "splash";
        new_layer.offset = { x: 0, y: 8 };
        new_layer.geometry = Array(16)
          .fill()
          .map(() => Array(16).fill(0));
        map.layers.splice(2, 0, new_layer);

        let water = map.layers[0];
        let ground = map.layers[1];
        let splash = map.layers[2];

        for (let y = 0; y < ground.geometry.length; y++) {
          for (let x = 0; x < ground.geometry[0].length; x++) {
            if (y - 1 > 0 && ground.geometry[y][x] !== 3 && ground.geometry[y - 1][x] == 3) {
              ground.geometry[y][x] = 2;
            }
          }
        }

        for (let y = 0; y < ground.geometry.length; y++) {
          for (let x = 0; x < ground.geometry[0].length; x++) {
            if (ground.geometry[y][x] == 2) {
              splash.geometry[y][x] = 16;
            }
          }
        }

        for (let y = 0; y < water.geometry.length; y++) {
          for (let x = 0; x < water.geometry[0].length; x++) {
            if (ground.geometry[y][x] == 3) {
              water.geometry[y][x] = 1;
            }

            if (ground.geometry[y][x] !== 3 && ground.geometry[y][x + 1] == 3) {
              water.geometry[y][x] = 1;
            }
            if (ground.geometry[y][x] !== 3 && ground.geometry[y][x - 1] == 3) {
              water.geometry[y][x] = 1;
            }
            if (y + 1 < water.geometry.length && ground.geometry[y][x] !== 3 && ground.geometry[y + 1][x] == 3) {
              water.geometry[y][x] = 1;
            }
            if (y - 1 > 0 && ground.geometry[y][x] !== 3 && ground.geometry[y - 1][x] == 3) {
              water.geometry[y][x] = 1;
            }
          }
        }

        for (let y = 0; y < water.geometry.length; y++) {
          for (let x = 0; x < water.geometry[0].length; x++) {
            if (water.geometry[y][x] == -1) {
              water.geometry[y][x] = 1;
            }
          }
        }
      });

      // ========== HTML OVERLAY SYSTEM FOR PRECISE TOUCH ==========
      let menuOverlayElements = {
        container: null,
        background: null,
        title: null,
        playButton: null,
        selectButton: null,
        instructionsButton: null,
        closeButton: null,
      };

      let levelsOverlayElements = {
        container: null,
        levelButtons: [],
        backButton: null,
      };

      let instructionsOverlayElements = {
        container: null,
        closeButton: null,
      };

      function createMenuOverlay() {
        // Remove existing overlay if it exists
        if (menuOverlayElements.container) {
          menuOverlayElements.container.remove();
        }

        // Create main container using same approach as control pad
        menuOverlayElements.container = document.createElement("div");
        menuOverlayElements.container.id = "menuOverlay";
        menuOverlayElements.container.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          pointer-events: none;
          z-index: 1000;
          display: none;
        `;

        // Helper function to create responsive button
        function createResponsiveButton(id, text, callback) {
          const button = document.createElement("div");
          button.id = id;
          button.textContent = text;
          button.style.cssText = `
            position: fixed;
            background: transparent;
            color: #000000;
            border: none;
            border-radius: 8px;
            font-family: "Pirata One", sans-serif;
            font-weight: bold;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            cursor: pointer;
            user-select: none;
            touch-action: manipulation;
            transition: all 0.2s ease;
            z-index: 1001;
          `;

          // Add touch events
          button.addEventListener("touchstart", (e) => {
            e.preventDefault();
            e.stopPropagation();
            button.style.transform = "scale(0.95)";
            button.style.background = "rgba(255, 215, 0, 0.2)";
          });

          button.addEventListener("touchend", (e) => {
            e.preventDefault();
            e.stopPropagation();
            button.style.transform = "scale(1)";
            button.style.background = "transparent";

            // Hide menu overlay immediately
            menuOverlayElements.container.style.display = "none";
            callback();
          });

          button.addEventListener("touchcancel", (e) => {
            e.preventDefault();
            button.style.transform = "scale(1)";
            button.style.background = "transparent";
          });

          // Add click events for desktop
          button.addEventListener("click", (e) => {
            e.preventDefault();
            e.stopPropagation();

            // Hide menu overlay immediately
            menuOverlayElements.container.style.display = "none";
            callback();
          });

          // Prevent context menu
          button.addEventListener("contextmenu", (e) => {
            e.preventDefault();
          });

          return button;
        }

        // Create background image
        menuOverlayElements.background = document.createElement("div");
        menuOverlayElements.background.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background-image: url("https://lqy3lriiybxcejon.public.blob.vercel-storage.com/6d6bc837-fad6-47ee-91cd-cdfeb472750a/The%20Open-Sea%20%289%29-ldKqKPyTn8Ki18H1iohz4CMPw1PFOV.png?oG0m");
          background-size: cover;
          background-position: center;
          background-repeat: no-repeat;
          pointer-events: none;
          user-select: none;
          z-index: 500;
        `;

        // Create buttons with callbacks
        menuOverlayElements.playButton = createResponsiveButton("playOverlay", "PLAY", () => {
          game.current_level = 1;
          resetGame();
          game.startScene("inGame");
        });

        menuOverlayElements.selectButton = createResponsiveButton("selectOverlay", "SELECT", () => {
          // Explicitly hide menu overlay
          menuOverlayElements.container.style.display = "none";
          game.startScene("levels");
        });

        menuOverlayElements.instructionsButton = createResponsiveButton("instructionsOverlay", "INSTRUCTIONS", () => {
          game.scenes.menu.showInstructions();
        });

        // Create instructions info text
        menuOverlayElements.instructionsInfo = document.createElement("div");
        menuOverlayElements.instructionsInfo.style.cssText = `
          position: fixed;
          bottom: 20px;
          left: 50%;
          transform: translateX(-50%);
          color: #FFD700;
          font-family: "Pirata One", sans-serif;
          font-size: 12px;
          text-align: center;
          display: none;
          z-index: 1003;
        `;
        menuOverlayElements.instructionsInfo.textContent = "Close with Back button or press X key";

        // Create instructional text box (like a button but non-interactive)
        menuOverlayElements.instructionalText = document.createElement("div");
        menuOverlayElements.instructionalText.textContent = 'Use arrows to move and "space" to start';
        menuOverlayElements.instructionalText.style.cssText = `
          position: fixed;
          background: rgba(0, 0, 0, 0.4);
          color: #FFD700;
          border: none;
          border-radius: 0;
          font-family: "Pirata One", sans-serif;
          font-weight: bold;
          text-align: center;
          display: flex;
          align-items: center;
          justify-content: center;
          pointer-events: none;
          user-select: none;
          z-index: 1001;
          padding: 18px 0;
          font-size: 14px;
        `;

        // Add background and buttons to container
        menuOverlayElements.container.appendChild(menuOverlayElements.background);
        menuOverlayElements.container.appendChild(menuOverlayElements.playButton);
        menuOverlayElements.container.appendChild(menuOverlayElements.selectButton);
        menuOverlayElements.container.appendChild(menuOverlayElements.instructionsButton);
        menuOverlayElements.container.appendChild(menuOverlayElements.instructionsInfo);
        menuOverlayElements.container.appendChild(menuOverlayElements.instructionalText);

        // Add to document
        document.body.appendChild(menuOverlayElements.container);

        // Initial update
        updateMenuOverlay();
      }

      function updateMenuOverlay() {
        if (!menuOverlayElements.container) return;
        if (!game || !game.scenes || !game.scenes.menu) return;

        const menu = game.scenes.menu;

        // Update container visibility
        menuOverlayElements.container.style.display =
          game.current_scene && game.current_scene.name === "menu" ? "block" : "none";

        if (!game.current_scene || game.current_scene.name !== "menu") {
          // Ensure menu is completely hidden when not in menu scene
          return;
        }

        // Get canvas position and dimensions for positioning within game area
        const canvas = game.canvas;
        const canvasRect = canvas.getBoundingClientRect();
        const canvasLeft = canvasRect.left;
        const canvasTop = canvasRect.top;
        const canvasWidth = canvasRect.width;
        const canvasHeight = canvasRect.height;
        const canvasCenterX = canvasLeft + canvasWidth / 2;

        // Use screen-based positioning for buttons (centered on screen)
        const screenWidth = window.innerWidth;
        const screenHeight = window.innerHeight;
        const screenCenterX = screenWidth / 2;

        // Fixed button width for consistency and better centering
        const buttonWidth = 180; // Fixed width for all buttons
        const buttonHeight = Math.min(40, screenHeight * 0.06); // Reduced height
        const fontSize = Math.min(16, buttonHeight * 0.4);

        // Center buttons in the middle of the screen (both X and Y)
        const startY = screenHeight * 0.45 - buttonHeight; // Moved up slightly
        const spacing = buttonHeight + 12; // Reduced spacing between buttons

        // Button positions
        const playY = startY;
        const selectY = startY + spacing;
        const instructionsY = startY + spacing * 2;

        // Get current selection for desktop styling
        const selectedButton =
          game.scenes.menu && game.scenes.menu.selectedButton !== undefined ? game.scenes.menu.selectedButton : 0;
        const isMobile = isMobileDevice();

        // Update instructional text position (55px below the last button)
        const instructionalText = menuOverlayElements.instructionalText;
        if (instructionalText) {
          const textBottomY = instructionsY + buttonHeight + 55; // 55px below last button (40 + 15)
          instructionalText.style.left = `0px`; // Full width
          instructionalText.style.top = `${textBottomY}px`;
          instructionalText.style.width = `100%`; // Full screen width
          instructionalText.style.bottom = "auto"; // Remove bottom positioning
        }

        // Force absolute positioning from screen coordinates
        // Update PLAY button with screen-based positioning
        const playButton = menuOverlayElements.playButton;
        playButton.style.position = "fixed";
        playButton.style.left = `${screenCenterX - buttonWidth / 2}px`;
        playButton.style.top = `${playY}px`;
        playButton.style.width = `${buttonWidth}px`;
        playButton.style.height = `${buttonHeight}px`;
        playButton.style.fontSize = `${fontSize}px`;
        playButton.style.transform = "none"; // Reset any transforms

        // Apply desktop/mobile specific styling
        if (isMobile) {
          playButton.style.color = "#FFD700";
          playButton.style.border = "2px solid #FFD700";
        } else {
          if (selectedButton === 0) {
            playButton.style.color = "#FFD700";
            playButton.style.border = "none";
            playButton.style.background = "transparent";
            playButton.style.fontSize = `${fontSize * 1.3}px`; // Much larger for selected
          } else {
            playButton.style.color = "#000000";
            playButton.style.border = "none";
            playButton.style.background = "transparent";
            playButton.style.fontSize = `${fontSize}px`; // Normal size for unselected
          }
        }

        // Update SELECT button
        const selectButton = menuOverlayElements.selectButton;
        selectButton.style.position = "fixed";
        selectButton.style.left = `${screenCenterX - buttonWidth / 2}px`;
        selectButton.style.top = `${selectY}px`;
        selectButton.style.width = `${buttonWidth}px`;
        selectButton.style.height = `${buttonHeight}px`;
        selectButton.style.fontSize = `${fontSize}px`;
        selectButton.style.transform = "none"; // Reset any transforms

        if (isMobile) {
          selectButton.style.color = "#FFD700";
          selectButton.style.border = "2px solid #FFD700";
        } else {
          if (selectedButton === 1) {
            selectButton.style.color = "#FFD700";
            selectButton.style.border = "none";
            selectButton.style.background = "transparent";
            selectButton.style.fontSize = `${fontSize * 1.3}px`; // Much larger for selected
          } else {
            selectButton.style.color = "#000000";
            selectButton.style.border = "none";
            selectButton.style.background = "transparent";
            selectButton.style.fontSize = `${fontSize}px`; // Normal size for unselected
          }
        }

        // Update INSTRUCTIONS button
        const instructionsButton = menuOverlayElements.instructionsButton;
        instructionsButton.style.position = "fixed";
        instructionsButton.style.left = `${screenCenterX - buttonWidth / 2}px`;
        instructionsButton.style.top = `${instructionsY}px`;
        instructionsButton.style.width = `${buttonWidth}px`;
        instructionsButton.style.height = `${buttonHeight}px`;
        instructionsButton.style.fontSize = `${fontSize}px`;
        instructionsButton.style.transform = "none"; // Reset any transforms

        if (isMobile) {
          instructionsButton.style.color = "#FFD700";
          instructionsButton.style.border = "2px solid #FFD700";
        } else {
          if (selectedButton === 2) {
            instructionsButton.style.color = "#FFD700";
            instructionsButton.style.border = "none";
            instructionsButton.style.background = "transparent";
            instructionsButton.style.fontSize = `${fontSize * 1.3}px`; // Much larger for selected
          } else {
            instructionsButton.style.color = "#000000";
            instructionsButton.style.border = "none";
            instructionsButton.style.background = "transparent";
            instructionsButton.style.fontSize = `${fontSize}px`; // Normal size for unselected
          }
        }

        // Update instructions overlay
        updateInstructionsOverlay();

        // Instructional text now has fixed positioning and doesn't need updates
      }

      function createLevelsOverlay() {
        // Remove any existing overlays (including orphaned ones)
        const existingOverlays = document.querySelectorAll("#levelsOverlay");
        existingOverlays.forEach((overlay) => overlay.remove());

        // Remove existing overlay if it exists in our reference
        if (levelsOverlayElements.container) {
          levelsOverlayElements.container.remove();
          levelsOverlayElements.container = null;
        }

        // Clear any existing level buttons references
        levelsOverlayElements.levelButtons = [];

        // Create main container
        levelsOverlayElements.container = document.createElement("div");
        levelsOverlayElements.container.id = "levelsOverlay";
        levelsOverlayElements.container.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: rgba(0, 0, 0, 0.8);
          pointer-events: none;
          z-index: 1500;
          display: none;
        `;

        // Add to document
        document.body.appendChild(levelsOverlayElements.container);
      }

      function updateLevelsOverlay() {
        if (!levelsOverlayElements.container) return;
        if (!game || !game.scenes || !game.scenes.levels) return;

        // Update container visibility
        levelsOverlayElements.container.style.display =
          game.current_scene && game.current_scene.name === "levels" ? "block" : "none";

        if (!game.current_scene || game.current_scene.name !== "levels") return;

        // Clear the entire container content to prevent duplicates
        levelsOverlayElements.container.innerHTML = "";

        // Clear existing level buttons array
        levelsOverlayElements.levelButtons = [];

        // Use screen-based positioning like the control pad
        const screenWidth = window.innerWidth;
        const screenHeight = window.innerHeight;
        const isMobile = isMobileDevice();

        // Create levels container box
        const levelsContainer = document.createElement("div");
        levelsContainer.style.cssText = `
          position: fixed;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          background: rgba(0, 0, 0, 0.8);
          border: 3px solid #FFD700;
          border-radius: 12px;
          padding: 30px;
          z-index: 1001;
          backdrop-filter: blur(5px);
          width: 90%;
          max-width: 600px;
          max-height: 80%;
          box-sizing: border-box;
        `;

        // Create title
        const title = document.createElement("h2");
        title.textContent = "SELECT LEVEL";
        title.style.cssText = `
          color: #FFD700;
          font-family: "Pirata One", sans-serif;
          font-size: 24px;
          margin: 0 0 20px 0;
          text-align: center;
        `;
        levelsContainer.appendChild(title);

        // Create grid container for levels
        const gridContainer = document.createElement("div");
        gridContainer.style.cssText = `
          display: grid;
          grid-template-columns: repeat(5, 1fr);
          grid-template-rows: repeat(4, 1fr);
          gap: 15px;
          margin-bottom: 20px;
        `;

        // Calculate responsive grid layout - made bigger to use more space
        const gridCols = 5;
        const gridRows = 4;
        const levelButtonSize = Math.min(70, Math.min(screenWidth, screenHeight) / 10);

        // Get current selection for desktop styling
        const selectedLevel =
          game.scenes.levels && game.scenes.levels.selection !== undefined ? game.scenes.levels.selection : 0;

        // Create level buttons
        const show = Math.min(game.mapsMax, 20);
        for (let i = 0; i < show; i++) {
          const level_id = i + 20 * Math.floor(selectedLevel / 20);

          const levelButton = document.createElement("div");
          levelButton.textContent = (level_id + 1).toString();

          // Determine if this level should be highlighted (desktop selection)
          const isSelected = !isMobile && selectedLevel === level_id;

          levelButton.style.cssText = `
            width: ${levelButtonSize}px;
            height: ${levelButtonSize}px;
            background: ${isSelected ? "#FFD700" : "transparent"};
            color: ${isSelected ? "#8B4513" : "#FFFFFF"};
            border: 2px solid ${isSelected ? "#8B4513" : "#FFD700"};
            border-radius: 8px;
            font-family: "Pirata One", sans-serif;
            font-size: ${Math.min(18, levelButtonSize * 0.25)}px;
            font-weight: bold;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            cursor: pointer;
            user-select: none;
            touch-action: manipulation;
            transition: all 0.1s ease;
          `;

          // Add touch effects (no hover effects for desktop)
          levelButton.addEventListener("touchstart", (e) => {
            e.preventDefault();
            e.stopPropagation();
            levelButton.style.transform = "scale(0.9)";
          });

          levelButton.addEventListener("touchend", (e) => {
            e.preventDefault();
            e.stopPropagation();
            levelButton.style.transform = "scale(1)";

            // Hide levels overlay immediately and start the selected level
            levelsOverlayElements.container.style.display = "none";
            game.current_level = level_id + 1;
            ensurePirateMusicPlaying();
            game.startScene("inGame");
          });

          levelButton.addEventListener("touchcancel", (e) => {
            e.preventDefault();
            levelButton.style.transform = "scale(1)";
          });

          levelButton.addEventListener("click", (e) => {
            e.preventDefault();
            e.stopPropagation();

            // Hide levels overlay immediately and start the selected level
            levelsOverlayElements.container.style.display = "none";
            game.current_level = level_id + 1;
            ensurePirateMusicPlaying();
            game.startScene("inGame");
          });

          // Prevent context menu
          levelButton.addEventListener("contextmenu", (e) => {
            e.preventDefault();
          });

          levelsOverlayElements.levelButtons.push(levelButton);
          gridContainer.appendChild(levelButton);
        }

        levelsContainer.appendChild(gridContainer);

        // Create instruction text
        const instructionText = document.createElement("div");
        instructionText.style.cssText = `
          color: #FFD700;
          font-family: "Pirata One", sans-serif;
          font-size: 14px;
          text-align: center;
          margin-bottom: 15px;
        `;

        if (isMobile) {
          instructionText.textContent = "Tap a level to play";
        } else {
          instructionText.textContent = "Use arrows to select, Space to confirm";
        }
        levelsContainer.appendChild(instructionText);

        // Create back button
        const backButton = document.createElement("div");
        backButton.textContent = "BACK TO MENU";
        backButton.style.cssText = `
          background: transparent;
          color: #FFD700;
          border: 2px solid #FFD700;
          border-radius: 8px;
          font-family: "Pirata One", sans-serif;
          font-size: 16px;
          font-weight: bold;
          text-align: center;
          display: flex;
          align-items: center;
          justify-content: center;
          pointer-events: auto;
          cursor: pointer;
          user-select: none;
          touch-action: manipulation;
          transition: all 0.1s ease;
          padding: 12px 24px;
          margin: 0 auto;
        `;

        // Add events to back button
        backButton.addEventListener("touchstart", (e) => {
          e.preventDefault();
          e.stopPropagation();
          backButton.style.transform = "scale(0.95)";
        });

        backButton.addEventListener("touchend", (e) => {
          e.preventDefault();
          e.stopPropagation();
          backButton.style.transform = "scale(1)";
          levelsOverlayElements.container.style.display = "none";
          game.startScene("menu");
          // Ensure menu buttons are visible
          setTimeout(() => {
            updateMenuOverlay();
          }, 50);
        });

        backButton.addEventListener("touchcancel", (e) => {
          e.preventDefault();
          backButton.style.transform = "scale(1)";
        });

        backButton.addEventListener("click", (e) => {
          e.preventDefault();
          e.stopPropagation();
          levelsOverlayElements.container.style.display = "none";
          game.startScene("menu");
          // Ensure menu buttons are visible
          setTimeout(() => {
            updateMenuOverlay();
          }, 50);
        });

        levelsContainer.appendChild(backButton);
        levelsOverlayElements.container.appendChild(levelsContainer);
      }

      function recreateMenuOverlay() {
        const wasVisible = menuOverlayElements.container && menuOverlayElements.container.style.display === "block";

        createMenuOverlay();

        if (wasVisible && game && game.current_scene && game.current_scene.name === "menu") {
          updateMenuOverlay();
        }
      }

      function recreateLevelsOverlay() {
        const wasVisible = levelsOverlayElements.container && levelsOverlayElements.container.style.display === "block";

        createLevelsOverlay();

        if (wasVisible && game && game.current_scene && game.current_scene.name === "levels") {
          updateLevelsOverlay();
        }
      }

      function createInstructionsOverlay() {
        // Remove existing overlay if it exists
        if (instructionsOverlayElements.container) {
          instructionsOverlayElements.container.remove();
        }

        // Create main container
        instructionsOverlayElements.container = document.createElement("div");
        instructionsOverlayElements.container.id = "instructionsOverlay";
        instructionsOverlayElements.container.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: rgba(0, 0, 0, 0.8);
          pointer-events: none;
          z-index: 1000;
          display: none;
        `;

        // Add to document
        document.body.appendChild(instructionsOverlayElements.container);
      }

      function updateInstructionsOverlay() {
        if (!instructionsOverlayElements.container) return;
        if (!game || !game.scenes || !game.scenes.menu) return;

        const menu = game.scenes.menu;

        // Update container visibility
        instructionsOverlayElements.container.style.display = menu.showingInstructions ? "block" : "none";

        if (!menu.showingInstructions) return;

        // Clear existing content
        instructionsOverlayElements.container.innerHTML = "";

        // Use screen-based positioning like the levels overlay
        const screenWidth = window.innerWidth;
        const screenHeight = window.innerHeight;
        const isMobile = isMobileDevice();

        // Create instructions container box
        const instructionsContainer = document.createElement("div");
        instructionsContainer.style.cssText = `
          position: fixed;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          background: rgba(0, 0, 0, 0.8);
          border: 3px solid #FFD700;
          border-radius: 12px;
          padding: 30px;
          z-index: 1001;
          backdrop-filter: blur(5px);
          width: 90%;
          max-width: 600px;
          max-height: 80%;
          box-sizing: border-box;
        `;

        // Create title
        const title = document.createElement("h2");
        title.textContent = "GAME INSTRUCTIONS";
        title.style.cssText = `
          color: #FFD700;
          font-family: "Pirata One", sans-serif;
          font-size: 24px;
          margin: 0 0 20px 0;
          text-align: center;
        `;
        instructionsContainer.appendChild(title);

        // Create instructions content
        const instructionsContent = document.createElement("div");
        instructionsContent.style.cssText = `
          color: #FFFFFF;
          font-family: "Pirata One", sans-serif;
          font-size: 14px;
          line-height: 1.6;
          margin-bottom: 20px;
          text-align: left;
          width: 100%;
          white-space: nowrap;
          overflow: visible;
        `;

        instructionsContent.innerHTML = `
          <p>1. Collect coins and take the OpenSea portal</p>
          <p>2. Escape quickly to earn more points</p>
          <p>3. Coins give you points - collect them all!</p>
          <p>4. If you fall into water, you lose</p>
          <p>5. Press red button (X Key) to surrender</p>
          <p>6. Complete levels to unlock new challenges</p>
        `;
        instructionsContainer.appendChild(instructionsContent);

        // Create close X button (top right corner)
        const closeButton = document.createElement("div");
        closeButton.textContent = "✕";
        closeButton.style.cssText = `
          position: absolute;
          top: 12px;
          right: 12px;
          color: #FFD700;
          font-family: "Pirata One", sans-serif;
          font-size: 16px;
          font-weight: bold;
          cursor: pointer;
          pointer-events: auto;
          user-select: none;
          touch-action: manipulation;
          width: 20px;
          height: 20px;
          display: flex;
          align-items: center;
          justify-content: center;
        `;

        // Add events to close button
        closeButton.addEventListener("click", (e) => {
          e.preventDefault();
          e.stopPropagation();
          game.scenes.menu.hideInstructions();
          // Ensure menu buttons are visible
          setTimeout(() => {
            updateMenuOverlay();
          }, 50);
        });

        closeButton.addEventListener("touchend", (e) => {
          e.preventDefault();
          e.stopPropagation();
          game.scenes.menu.hideInstructions();
          // Ensure menu buttons are visible
          setTimeout(() => {
            updateMenuOverlay();
          }, 50);
        });

        instructionsContainer.appendChild(closeButton);

        // Create instruction text for closing
        const instructionText = document.createElement("div");
        instructionText.style.cssText = `
          color: #FFD700;
          font-family: "Pirata One", sans-serif;
          font-size: 14px;
          text-align: center;
          margin-bottom: 15px;
        `;

        instructionText.textContent = "Press X or 'Back to menu' button to close";
        instructionsContainer.appendChild(instructionText);

        // Create back button
        const backButton = document.createElement("div");
        backButton.textContent = "BACK TO MENU";
        backButton.style.cssText = `
          background: transparent;
          color: #FFD700;
          border: 2px solid #FFD700;
          border-radius: 8px;
          font-family: "Pirata One", sans-serif;
          font-size: 16px;
          font-weight: bold;
          text-align: center;
          display: flex;
          align-items: center;
          justify-content: center;
          pointer-events: auto;
          cursor: pointer;
          user-select: none;
          touch-action: manipulation;
          transition: all 0.1s ease;
          padding: 12px 24px;
          margin: 0 auto;
        `;

        // Add events to back button
        backButton.addEventListener("touchstart", (e) => {
          e.preventDefault();
          e.stopPropagation();
          backButton.style.transform = "scale(0.95)";
        });

        backButton.addEventListener("touchend", (e) => {
          e.preventDefault();
          e.stopPropagation();
          backButton.style.transform = "scale(1)";
          game.scenes.menu.hideInstructions();
          // Ensure menu buttons are visible
          setTimeout(() => {
            updateMenuOverlay();
          }, 50);
        });

        backButton.addEventListener("touchcancel", (e) => {
          e.preventDefault();
          backButton.style.transform = "scale(1)";
        });

        backButton.addEventListener("click", (e) => {
          e.preventDefault();
          e.stopPropagation();
          game.scenes.menu.hideInstructions();
          // Ensure menu buttons are visible
          setTimeout(() => {
            updateMenuOverlay();
          }, 50);
        });

        instructionsContainer.appendChild(backButton);
        instructionsOverlayElements.container.appendChild(instructionsContainer);

        // Add click anywhere to close functionality
        instructionsOverlayElements.container.addEventListener("click", (e) => {
          if (e.target === instructionsOverlayElements.container) {
            game.scenes.menu.hideInstructions();
            // Ensure menu buttons are visible
            setTimeout(() => {
              updateMenuOverlay();
            }, 50);
          }
        });

        instructionsOverlayElements.container.style.pointerEvents = "auto";
      }

      function recreateInstructionsOverlay() {
        createInstructionsOverlay();

        if (game && game.current_scene && game.current_scene.name === "menu" && game.scenes.menu.showingInstructions) {
          updateInstructionsOverlay();
        }
      }

      // ========== END HTML OVERLAY SYSTEM ==========

      // ========== SCORE AND TIMER SYSTEM ==========
      let gameScore = 0;
      let levelTime = 30;
      let timerInterval = null;
      let showHUD_flag = false;
      const BASE_POINTS_PER_LEVEL = 100;

      // Surrender button variables (legacy - no longer used for positioning)
      let surrenderButtonX = 650;
      let surrenderButtonY = 100;
      let surrenderButtonSize = 160;

      function showHUD() {
        showHUD_flag = true;

        // Show the dynamically created HUD
        if (hudElements.container) {
          hudElements.container.style.display = "block";
        }

        // Show control pad for mobile devices when entering game
        updateControlPadVisibility("inGame");

        // Add event listener for surrender button (only once)
        if (hudElements.surrenderButton && !hudElements.surrenderButton.hasAttribute("data-listener-added")) {
          hudElements.surrenderButton.addEventListener("click", function () {
            // Farcade SDK: Haptic feedback for surrender button
            if (window.FarcadeSDK) {
              window.FarcadeSDK.singlePlayer.actions.hapticFeedback();
            }
            surrenderGame(game);
          });
          hudElements.surrenderButton.setAttribute("data-listener-added", "true");
        }

        // Also show hints during gameplay
        // showHints();

        updateHUD();
      }

      function hideHUD() {
        showHUD_flag = false;

        // Hide the dynamically created HUD
        if (hudElements.container) {
          hudElements.container.style.display = "none";
        }

        // Hide control pad when leaving game
        updateControlPadVisibility("menu");

        if (timerInterval) {
          clearInterval(timerInterval);
          timerInterval = null;
        }

        // Also hide hints when hiding HUD
        // hideHints();
      }

      function updateScore() {
        updateHUD();
      }

      function updateTimer() {
        updateHUD();
      }

      function updateHUD() {
        // Update score display - use dynamic elements
        const scoreElement = document.getElementById("scoreValue");
        if (scoreElement) {
          scoreElement.textContent = gameScore;
        }

        // Update timer display with color based on time remaining - use dynamic elements
        const timerElement = document.getElementById("timerValue");
        if (timerElement) {
          timerElement.textContent = levelTime;

          // Change color when time is low - apply to parent element
          const timerDisplay = timerElement.parentElement;
          if (timerDisplay) {
            if (levelTime <= 10) {
              timerDisplay.style.color = "#ff4444";
              timerDisplay.style.textShadow = "2px 2px 0px rgba(0, 0, 0, 0.9)"; // Darker shadow for better contrast
            } else {
              timerDisplay.style.color = "#ffffff";
              timerDisplay.style.textShadow = "3px 3px 0px rgba(0, 0, 0, 0.8)";
            }
          }
        }
      }

      function startLevelTimer(gameWorld) {
        levelTime = 30;
        updateHUD();

        if (timerInterval) {
          clearInterval(timerInterval);
        }

        timerInterval = setInterval(() => {
          levelTime--;
          updateHUD();

          if (levelTime <= 0) {
            clearInterval(timerInterval);
            timerInterval = null;
            // Game Over - Time's up
            gameOverTimeUp(gameWorld);
          }
        }, 1000);
      }

      function calculateLevelScore(timeRemaining) {
        // Base points multiplied by time remaining multiplier
        // More time remaining = higher multiplier
        let timeMultiplier = 1 + timeRemaining / 30; // 1x to 2x multiplier
        return Math.floor(BASE_POINTS_PER_LEVEL * timeMultiplier);
      }

      function levelCompleted(gameWorld) {
        if (timerInterval) {
          clearInterval(timerInterval);
          timerInterval = null;
        }

        let levelPoints = calculateLevelScore(levelTime);
        gameScore += levelPoints;
        updateScore();

        // Farcade SDK: Haptic feedback for level completion
        if (window.FarcadeSDK) {
          window.FarcadeSDK.singlePlayer.actions.hapticFeedback();
        }

        // Keep HUD visible for a moment to show final score
        // Don't hide HUD here - let the transition handle it

        // Continue with normal level completion logic
      }

      function gameOverTimeUp(gameWorld) {
        hideHUD();
        stopAllMusic(); // Stop background music

        // Capture final score for SDK integration later
        console.log("GAME OVER - Final Score:", gameScore);

        // Farcade SDK: Report game over with score
        if (window.FarcadeSDK) {
          window.FarcadeSDK.singlePlayer.actions.gameOver({ score: gameScore });
        }

        // Reset game to level 1 for next play
        gameWorld.current_level = 1;
        resetGame();

        // Return to menu (menu will start its own music)
        gameWorld.startScene("menu");
      }

      function surrenderGame(gameWorld) {
        hideHUD();
        stopAllMusic(); // Stop background music

        // Capture final score for SDK integration later
        console.log("GAME OVER - Player Surrendered - Final Score:", gameScore);

        // Farcade SDK: Report game over with score
        if (window.FarcadeSDK) {
          window.FarcadeSDK.singlePlayer.actions.gameOver({ score: gameScore });
        }

        // Reset game to level 1 for next play
        gameWorld.current_level = 1;
        resetGame();

        // Return to menu (menu will start its own music)
        gameWorld.startScene("menu");
      }
      function resetGame() {
        gameScore = 0;
        levelTime = 30;
        updateScore();
        updateTimer();
      }

      // ========== HINTS SYSTEM ==========
      let currentHintIndex = 0;
      let hintInterval = null;
      let showHints_flag = false;

      const gameHints = [
        "Take all the coins, or not...",
        "Yo ho ho and a bottle of rum!",
        "Be fast and get more points...",
        "Dead men tell no tales...",
        "Coins give you more points...",
        "Aye, aye, Captain!",
        "🔴 Use red button to surrender (S key)",
        "📱 Swipe on screen to move (mobile)",
      ];

      const HINT_FADE_SPEED = 0.02;
      const HINT_DISPLAY_DURATION = 5000; // 5 seconds (increased from 3)
      const HINT_FADE_DURATION = 500; // 0.5 seconds

      /*
      function showHints() {
        showHints_flag = true;
        console.log("Showing hints - setting display block");
        document.getElementById("gameHints").style.display = "block";

        // Start hint rotation if not already running
        if (!hintInterval) {
          console.log("Starting hint rotation");
          startHintRotation();
        }
      }

      function hideHints() {
        showHints_flag = false;
        document.getElementById("gameHints").style.display = "none";

        if (hintInterval) {
          clearInterval(hintInterval);
          hintInterval = null;
        }

        // Reset hint state
        currentHintIndex = 0;
        const hintElement = document.getElementById("hintText");
        if (hintElement) {
          hintElement.classList.remove("visible");
        }
      }
      */

      /*
      function startHintRotation() {
        if (hintInterval) {
          clearInterval(hintInterval);
        }

        // Show first hint immediately
        displayCurrentHint();

        // Set up interval for hint rotation
        hintInterval = setInterval(() => {
          const hintElement = document.getElementById("hintText");
          if (hintElement) {
            // Fade out current hint
            hintElement.classList.remove("visible");

            // After fade transition, change text and fade in
            setTimeout(() => {
              currentHintIndex = (currentHintIndex + 1) % gameHints.length;
              displayCurrentHint();
            }, 300); // Match CSS transition duration
          }
        }, HINT_DISPLAY_DURATION);
      }

      function displayCurrentHint() {
        const hintElement = document.getElementById("hintText");
        console.log("displayCurrentHint called", {
          hintElement: !!hintElement,
          currentHintIndex,
          hint: gameHints[currentHintIndex],
        });

        if (hintElement && gameHints[currentHintIndex]) {
          hintElement.textContent = gameHints[currentHintIndex];
          // Small delay to ensure text is updated before fade in
          setTimeout(() => {
            hintElement.classList.add("visible");
            console.log("Added visible class to hint element");
          }, 50);
        }
      }
      */
      // ========== END HINTS SYSTEM ==========

      // ========== BACKGROUND MUSIC SYSTEM ==========
      let currentBackgroundMusic = null;
      let pirateTracks = ["pirate1"]; // Reduced to single track for faster loading
      let currentTrackIndex = 0;
      let musicVolume = 0.08; // Softer volume level

      function stopAllMusic() {
        // Stop menu music
        if (game && game.assets && game.assets.audio && game.assets.audio.jingle) {
          game.assets.audio.jingle.audio.pause();
          game.assets.audio.jingle.audio.currentTime = 0;
        }

        // Stop any background music
        if (currentBackgroundMusic) {
          currentBackgroundMusic.pause();
          currentBackgroundMusic.currentTime = 0;
          currentBackgroundMusic = null;
        }
      }

      function playRandomPirateMusic() {
        if (!game || !game.assets || !game.assets.audio) return;

        // Stop any current background music
        if (currentBackgroundMusic) {
          currentBackgroundMusic.pause();
          currentBackgroundMusic = null;
        }

        // Randomly select a pirate track
        currentTrackIndex = Math.floor(Math.random() * pirateTracks.length);
        let trackName = pirateTracks[currentTrackIndex];

        if (game.assets.audio[trackName] && game.assets.audio[trackName].audio) {
          currentBackgroundMusic = game.assets.audio[trackName].audio;
          currentBackgroundMusic.volume = musicVolume;
          currentBackgroundMusic.currentTime = 0;
          currentBackgroundMusic.loop = false; // Don't loop, we'll pick random next

          // When track ends, play another random track
          currentBackgroundMusic.addEventListener(
            "ended",
            function () {
              // Small delay before next track to avoid performance issues
              setTimeout(() => {
                playRandomPirateMusic();
              }, 2000);
            },
            { once: true },
          );

          currentBackgroundMusic.play().catch((e) => {
            console.log("Could not play background music:", e);
          });
        }
      }

      function ensurePirateMusicPlaying() {
        // Only start pirate music if no music is currently playing
        if (
          !currentBackgroundMusic ||
          currentBackgroundMusic.paused ||
          currentBackgroundMusic.ended ||
          currentBackgroundMusic.currentTime === 0
        ) {
          console.log("Starting new pirate music...");
          playRandomPirateMusic();
        } else {
          console.log("Pirate music already playing, continuing...");
        }
      }

      function playMenuMusic() {
        stopAllMusic();

        if (game && game.assets && game.assets.audio && game.assets.audio.jingle) {
          game.assets.audio.jingle.audio.volume = musicVolume;
          game.assets.audio.jingle.audio.loop = true;
          game.assets.audio.jingle.audio.currentTime = 0;
          game.assets.audio.jingle.audio.play().catch((e) => {
            console.log("Could not play menu music:", e);
          });
        }
      }

      function ensureMenuMusicPlaying() {
        // Check if menu music is already playing
        if (
          game &&
          game.assets &&
          game.assets.audio &&
          game.assets.audio.jingle &&
          !game.assets.audio.jingle.audio.paused &&
          game.assets.audio.jingle.audio.currentTime > 0
        ) {
          console.log("Menu music already playing, continuing...");
          return;
        }

        // Start menu music if not playing
        console.log("Starting menu music...");
        playMenuMusic();
      }
      // ========== END BACKGROUND MUSIC SYSTEM ==========

      // ========== END SCORE AND TIMER SYSTEM ==========

      // ========== MENU BUTTONS MANAGEMENT ==========
      // Buttons are now drawn directly on canvas - no HTML management needed
      // ========== END MENU BUTTONS MANAGEMENT ==========

      // menu scene
      let menu = new Scene("menu");
      menu.keyEvents = function (event) {
        // If instructions are showing, close them with X (not Space)
        if (this.showingInstructions && event.code === "KeyX" && event.type === "keydown") {
          // Don't close immediately if just opened
          if (this.justOpenedInstructions) {
            return;
          }
          this.hideInstructions();
          return;
        }

        // Don't handle other keys if instructions are showing
        if (this.showingInstructions) return;

        // Check if we're on mobile - if so, only handle Space
        if (isMobileDevice()) {
          if (event.code === "Space" && event.type === "keydown") {
            // No sound for mobile selection - removed audio play

            // Start game
            game.current_level = 1;
            resetGame();
            game.startScene("inGame");
          }
          return;
        }

        // Desktop navigation with arrows
        if (event.type === "keydown") {
          if (event.code === "ArrowDown") {
            if (this.selectedButton < 2) {
              this.selectedButton++;
              // No sound for navigation - removed audio play
              // Update menu overlay to reflect selection change
              updateMenuOverlay();
            }
          } else if (event.code === "ArrowUp") {
            if (this.selectedButton > 0) {
              this.selectedButton--;
              // No sound for navigation - removed audio play
              // Update menu overlay to reflect selection change
              updateMenuOverlay();
            }
          } else if (event.code === "Space") {
            // No sound for selection confirmation - removed audio play

            // Execute selected action
            switch (this.selectedButton) {
              case 0: // PLAY
                game.current_level = 1;
                resetGame();
                game.startScene("inGame");
                break;
              case 1: // SELECT
                game.startScene("levels");
                break;
              case 2: // INSTRUCTIONS
                this.showInstructions();
                break;
            }
          }
        }
      };

      menu.init = function () {
        console.log("MENU INIT: Starting menu initialization");
        this.init_once = true;

        // Initialize menu state
        this.selectedButton = 0; // 0=PLAY, 1=SELECT, 2=INSTRUCTIONS
        this.showingInstructions = false;

        // Play menu music (waves sound)
        playMenuMusic();

        // background
        /* Commented out - pattern image removed
        let background_image = this.world.assets.image.pattern.image;
        this.pattern = this.world.ctx.createPattern(background_image, "repeat");
        */
        // Create a simple gradient background instead
        this.pattern = null;
        this.offset = {
          x: 0,
          y: 0,
        };
        // add cat on
        this.cat = new Entity(this, -this.world.tile_size, -this.world.tile_size);
        let idle_sprite_data = {
          image: "pirate_captain_idle",
          size: {
            x: 32,
            y: 32,
          },
        };
        let walk_sprite_data = {
          image: "pirate_captain_walk",
          size: {
            x: 32,
            y: 32,
          },
        };
        this.cat.playerSprite = new PlayerSprite(this.cat, idle_sprite_data, walk_sprite_data);
        this.cat.playerSprite.offset = { x: 0, y: -8 };

        // Force update menu overlay positioning after initialization
        setTimeout(() => {
          updateMenuOverlay();
        }, 100);
      };
      menu.render = function () {
        // Clear canvas and background image now handled by HTML overlay
        this.world.clear("black");

        // Background image now handled by HTML overlay for full screen coverage
        /*
        // Draw the island background image to fill the canvas
        let backgroundImage = null;
        if (this.world.assets.image["menu_background_island"]) {
          backgroundImage =
            this.world.assets.image["menu_background_island"].image;
        }

        if (backgroundImage) {
          this.ctx.save();
          this.ctx.imageSmoothingEnabled = true;
          this.ctx.imageSmoothingQuality = "high";

          // Draw the background image to fit the canvas
          this.ctx.drawImage(
            backgroundImage,
            0,
            0,
            backgroundImage.width,
            backgroundImage.height, // Source
            0,
            0,
            this.world.W,
            this.world.H // Destination: full canvas
          );

          this.ctx.restore();
        } else {
          // Fallback: draw a simple ocean gradient background
          let gradient = this.ctx.createLinearGradient(0, 0, 0, this.world.H);
          gradient.addColorStop(0, "#1e3a8a"); // Deep blue
          gradient.addColorStop(0.5, "#2563eb"); // Medium blue
          gradient.addColorStop(1, "#1e40af"); // Darker blue
          this.ctx.fillStyle = gradient;
          this.ctx.fillRect(0, 0, this.world.W, this.world.H);
        }
        */

        // Draw the title "The Open-Sea" - now handled by HTML overlay
        /*
        this.ctx.save();
        this.ctx.font = "36px 'Pirata One', sans-serif";
        this.ctx.textAlign = "center";
        this.ctx.textBaseline = "middle";

        let titleX = this.world.W / 2;
        let titleY = 40; // Moved closer to top

        // Draw black outline (5 pixels thick)
        this.ctx.strokeStyle = "#000000";
        this.ctx.lineWidth = 10; // 5 pixels on each side = 10 total width
        this.ctx.strokeText("The Open-Sea", titleX, titleY);

        // Draw white text
        this.ctx.fillStyle = "#FFFFFF";
        this.ctx.fillText("The Open-Sea", titleX, titleY);

        this.ctx.restore();
        */

        // Instructions now handled by HTML overlay - but still call the function for compatibility
        this.drawInstructions();
      };

      menu.showInstructions = function () {
        this.showingInstructions = true;
        this.instructionsStartTime = Date.now();

        // Prevent immediate closing by setting a small delay flag
        this.justOpenedInstructions = true;
        setTimeout(() => {
          this.justOpenedInstructions = false;
        }, 100); // 100ms delay to prevent immediate closing

        // Update the instructions overlay
        updateInstructionsOverlay();
      };

      menu.hideInstructions = function () {
        this.showingInstructions = false;
        // Update the instructions overlay to hide it
        updateInstructionsOverlay();
        // Ensure menu buttons are visible
        setTimeout(() => {
          updateMenuOverlay();
        }, 50);
      };

      menu.drawInstructions = function () {
        // Instructions now handled by HTML overlay - no canvas rendering needed
        let modalX = 20;
      };
      menu.animatedBackground = function () {
        // Smooth ocean-like movement simulation
        let time = Date.now() * 0.001; // Convert to seconds for smooth animation

        // Create wave-like movement with multiple sine waves for more natural effect
        this.offset.x += 0.3 + Math.sin(time * 0.5) * 0.2; // Base movement + wave variation
        this.offset.y += 0.2 + Math.cos(time * 0.3) * 0.15; // Slower vertical movement

        // Add a secondary wave for more complex movement
        this.offset.x += Math.sin(time * 1.2) * 0.1;
        this.offset.y += Math.cos(time * 0.8) * 0.1;

        if (this.offset.x > 63) {
          this.offset.x = 0;
        }
        if (this.offset.y > 63) {
          this.offset.y = 0;
        }
        let ctx = this.world.ctx;
        ctx.save();
        ctx.translate(this.offset.x, this.offset.y);

        // Use a simple gradient background instead of pattern
        if (this.pattern) {
          ctx.fillStyle = this.pattern;
        } else {
          // Create a simple ocean-like gradient
          let gradient = ctx.createLinearGradient(0, 0, 0, this.world.H);
          gradient.addColorStop(0, "#1e3a8a"); // Deep blue
          gradient.addColorStop(0.5, "#2563eb"); // Medium blue
          gradient.addColorStop(1, "#1e40af"); // Darker blue
          ctx.fillStyle = gradient;
        }

        ctx.fillRect(-this.offset.x, -this.offset.y, this.world.W, this.world.H);
        ctx.restore();
      };
      let levels = new Scene("levels");
      levels.keyEvents = function (event) {
        // Only allow Arrow Keys, Space, and X
        if (
          event.code !== "ArrowUp" &&
          event.code !== "ArrowDown" &&
          event.code !== "ArrowLeft" &&
          event.code !== "ArrowRight" &&
          event.code !== "Space" &&
          event.code !== "KeyX"
        ) {
          return; // Ignore other keys
        }

        // Handle X key to go back to menu (works on both mobile and desktop)
        if (event.code === "KeyX" && event.type === "keydown") {
          // No sound when going back - removed audio play
          this.world.startScene("menu");
          // Ensure menu buttons are visible
          setTimeout(() => {
            updateMenuOverlay();
          }, 50);
          return;
        }

        // On mobile devices, ignore navigation keys (only allow X and touch/click)
        if (isMobileDevice()) {
          return; // Mobile users must tap on levels
        }

        // Desktop navigation with arrow keys and space (only on keydown)
        if (event.type === "keydown") {
          if (event.code === "ArrowDown") {
            if (this.selection + 5 < this.world.mapsMax) {
              // No sound for navigation - removed audio play
              this.selection += 5;
              // Update levels overlay to reflect selection change
              updateLevelsOverlay();
            }
          } else if (event.code === "ArrowUp") {
            if (this.selection - 5 >= 0) {
              // No sound for navigation - removed audio play
              this.selection -= 5;
              // Update levels overlay to reflect selection change
              updateLevelsOverlay();
            }
          } else if (event.code === "ArrowRight") {
            if (this.selection + 1 < this.world.mapsMax) {
              // No sound for navigation - removed audio play
              this.selection += 1;
              // Update levels overlay to reflect selection change
              updateLevelsOverlay();
            }
          } else if (event.code === "ArrowLeft") {
            if (this.selection - 1 >= 0) {
              // No sound for navigation - removed audio play
              this.selection -= 1;
              // Update levels overlay to reflect selection change
              updateLevelsOverlay();
            }
          } else if (event.code === "Space") {
            // No sound for level selection - removed audio play
            this.world.current_level = this.selection + 1;

            // Start pirate music only when level is selected and game begins
            ensurePirateMusicPlaying();

            this.world.startScene("inGame");
          }
        }
      };

      levels.init = function () {
        this.init_once = true;
        this.selection = 0;
        this.scale = 0;

        // Don't play pirate music in level selection - keep only menu music (waves)
        // The pirate music will start when a level is actually selected and game begins

        // Force update levels overlay positioning after initialization
        setTimeout(() => {
          updateLevelsOverlay();
        }, 100);
      };
      levels.render = function () {
        // Clear canvas and draw gradient background like instructions modal
        this.world.clear("black");

        // Draw same gradient background as instructions modal
        let gradient = this.ctx.createLinearGradient(0, 0, 0, this.world.H);
        gradient.addColorStop(0, "#1a1a2e");
        gradient.addColorStop(1, "#16213e");
        this.ctx.fillStyle = gradient;
        this.ctx.fillRect(0, 0, this.world.W, this.world.H);

        // Level selection now handled by HTML overlay - no canvas rendering needed
      };
      let inGame = new Scene("inGame");
      inGame.keyEvents = function (event) {
        // Only allow Arrow Keys, WASD, Space, and X for surrender
        if (
          event.code !== "ArrowUp" &&
          event.code !== "ArrowDown" &&
          event.code !== "ArrowLeft" &&
          event.code !== "ArrowRight" &&
          event.code !== "KeyW" &&
          event.code !== "KeyA" &&
          event.code !== "KeyS" &&
          event.code !== "KeyD" &&
          event.code !== "Space" &&
          event.code !== "KeyX"
        ) {
          return; // Ignore other keys
        }

        // Handle surrender with X key (for consistency)
        if (event.code === "KeyX" && event.type === "keydown") {
          // Farcade SDK: Haptic feedback for surrender key
          if (window.FarcadeSDK) {
            window.FarcadeSDK.singlePlayer.actions.hapticFeedback();
          }
          surrenderGame(game);
          return;
        }

        // Remove E and R key handling - only allow Arrow Keys, WASD, and Space
      };
      inGame.init = function () {
        this.won = false;
        this.userInput = true;
        this.world.initMap("map_" + this.world.current_level);

        // Ensure pirate music is playing, but don't restart if already playing
        ensurePirateMusicPlaying();

        // Show HUD and start timer - ensure HUD is always visible during gameplay
        showHUD();
        updateScore();
        startLevelTimer(this.world);

        this.cats = [];
        let spawn_cat = () => {
          // add cats on spawn tile_size
          let spawns = this.world.findTile(3, 7);
          spawns.forEach((spawn) => {
            this.addCat(spawn.x, spawn.y);
          });
        };

        // effects
        this.effects = [];
        // transition effects
        this.transition = {
          scene: this,
          active: true,
          // between 0 and 100
          state: 0,
          value: 0,
          duration: 500,
          start: 0,
          // between whatever and whatever
          from: 0,
          to: Math.max(this.world.W, this.world.H),
          //
          start: function (from, to, callback) {
            this.scene.userInput = false;
            this.active = true;
            this.from = from;
            this.start_time = new Date();
            this.to = to;
            this.callback = callback;
          },
          update: function () {
            let time = new Date() - this.start_time;
            if (time < this.duration) {
              this.value = Util.easeInOutQuad(time, this.from, this.to - this.from, this.duration);
            } else {
              this.active = false;
              this.scene.userInput = true;
              if (this.callback !== undefined) {
                this.callback();
              }
            }
          },
          render: function () {
            this.scene.ctx.fillStyle = "black";
            this.scene.ctx.fillRect(0, 0, this.scene.world.W, this.value);
            this.scene.ctx.fillRect(0, this.scene.world.H, this.scene.world.W, -this.value);
            this.scene.ctx.fillRect(0, 0, this.value, this.scene.world.H);
            this.scene.ctx.fillRect(this.scene.world.W, 0, -this.value, this.scene.world.H);
          },
        };
        this.transition.start(Math.max(this.world.W / 2, this.world.H / 2), 0, spawn_cat);
      };
      inGame.addCat = function (x, y) {
        let cat = new Cat(this, x, y);
        let idle_sprite_data = {
          image: "pirate_captain_idle",
          size: {
            x: 32,
            y: 32,
          },
        };
        let walk_sprite_data = {
          image: "pirate_captain_walk",
          size: {
            x: 32,
            y: 32,
          },
        };
        cat.playerSprite = new PlayerSprite(cat, idle_sprite_data, walk_sprite_data);
        cat.playerSprite.offset = { x: 0, y: -8 };
        let spawn_data = {
          image: "spawn_effect",
          frames: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12],
          size: {
            x: 20,
            y: 40,
          },
        };
        let spawn_effect = new Effect(this, spawn_data, x, y - 1, () => {
          this.cats.push(cat);
        });
        spawn_effect.trigger = 4;
        this.effects.push(spawn_effect);
      };

      inGame.render = function () {
        this.control();
        this.world.renderMap();

        for (let i = this.cats.length; i--; ) {
          this.cats[i].playerSprite.animate();
          // draw shadow and cat
          this.ctx.drawImage(
            this.world.assets.image["shadow"].image,
            this.cats[i].body.position.x,
            this.cats[i].body.position.y + 2,
          );
          this.cats[i].playerSprite.display();
          this.cats[i].translation();
        }
        for (let i = this.effects.length; i--; ) {
          this.effects[i].render();
        }
        if (this.transition.active) {
          this.transition.update();
          this.transition.render();
        }

        // Update HUD if visible (now rendered outside canvas)
        if (showHUD_flag) {
          updateHUD();
        }
      };

      // Global function to render scaled sprite text on external canvas
      function renderScaledTextOnCanvas(ctx, text, centerX, y, scale, colorID) {
        // Wait for game to be fully loaded
        if (!game || !game.fonts || !game.currentFont || !game.fonts[game.currentFont]) {
          // Fallback: render with browser font temporarily
          ctx.font = "bold " + 16 * scale + "px monospace";
          ctx.fillStyle = colorID === 1 ? "#ff4444" : "#ffffff";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.strokeStyle = "#000000";
          ctx.lineWidth = 2;
          ctx.strokeText(text, centerX, y);
          ctx.fillText(text, centerX, y);
          return;
        }

        let size_x = game.fonts[game.currentFont].size.x;
        let size_y = game.fonts[game.currentFont].size.y;
        let font_img = game.fonts[game.currentFont].image;

        // Make sure the font image is loaded
        if (!font_img || !font_img.complete) {
          // Use fallback again if image not ready
          ctx.font = "bold " + 16 * scale + "px monospace";
          ctx.fillStyle = colorID === 1 ? "#ff4444" : "#ffffff";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.strokeStyle = "#000000";
          ctx.lineWidth = 2;
          ctx.strokeText(text, centerX, y);
          ctx.fillText(text, centerX, y);
          return;
        }

        // Calculate total width of scaled text for centering
        let totalWidth = text.length * size_x * scale;
        let startX = centerX - totalWidth / 2;

        // Render each character with scaling
        for (let i = 0; i < text.length; i++) {
          let char = text.charAt(i);
          let index = game.alphabet.indexOf(char);
          if (index !== -1) {
            let clipX = size_x * index;
            let posX = startX + i * size_x * scale;

            try {
              ctx.drawImage(
                font_img,
                clipX,
                colorID * size_y,
                size_x,
                size_y,
                posX,
                y - (size_y * scale) / 2,
                size_x * scale,
                size_y * scale,
              );
            } catch (e) {
              // Fallback if drawImage fails
              console.warn("Failed to draw sprite character:", char, e);
            }
          }
        }
      }

      // Add touch support for mobile devices in game
      inGame.mouseEvents = function (event) {
        if (!this.userInput) return;

        // The improved touch handling is now managed by the main engine
        // This function mainly handles any game-specific mouse/touch interactions
        // that aren't movement-related (e.g., UI interactions)

        // For movement, we rely on the improved touch system in the main engine
        // which handles hold gestures, continuous movement, and better zone detection
      };

      inGame.control = function () {
        if (this.userInput == false) return false;

        // Arrow keys
        if (this.world.keys.ArrowUp) {
          this.moveCats(0, -1);
        }
        if (this.world.keys.ArrowDown) {
          this.moveCats(0, 1);
        }
        if (this.world.keys.ArrowLeft) {
          this.moveCats(-1, 0);
        }
        if (this.world.keys.ArrowRight) {
          this.moveCats(1, 0);
        }

        // WASD keys
        if (this.world.keys.KeyW) {
          this.moveCats(0, -1);
        }
        if (this.world.keys.KeyS) {
          this.moveCats(0, 1);
        }
        if (this.world.keys.KeyA) {
          this.moveCats(-1, 0);
        }
        if (this.world.keys.KeyD) {
          this.moveCats(1, 0);
        }
      };
      inGame.moveCats = function (x, y) {
        // see if every cat are ready to move
        let canMove = this.cats.every((cat) => {
          return cat.inTranslation == false;
        });
        if (!canMove) return false;
        this.cats.forEach((cat) => {
          if (cat.canBeControlled === false) return false;
          if (cat.isDead) return false;
          cat.move(x, y);
        });
        this.collisionCats();
        this.cats.forEach((cat) => {
          cat.applyMove();
        });
      };
      inGame.collisionCats = function () {
        // check for other cats !
        let need_to_check = true;
        while (need_to_check === true) {
          need_to_check = false;
          this.cats.forEach((cat) => {
            if (cat.checkOthers()) {
              cat.target = cat.old_position.copy();
              need_to_check = true;
            }
          });
        }
      };

      inGame.collisionCoins = function () {
        // Check if cats are on coin tiles
        this.cats.forEach((cat) => {
          // Check both layers for coins
          let tileLayer1 = this.world.getTile(1, cat.target.x, cat.target.y);
          let tileLayer3 = this.world.getTile(3, cat.target.x, cat.target.y);

          // Check for coin in either layer
          let coinFound = false;
          let coinLayer = null;

          if (tileLayer1 && tileLayer1.name === "coin") {
            coinFound = true;
            coinLayer = 1;
          } else if (tileLayer3 && tileLayer3.name === "coin") {
            coinFound = true;
            coinLayer = 3;
          }

          if (coinFound) {
            // Remove the coin from the map
            this.world.setTile(coinLayer, cat.target.x, cat.target.y, 0);

            // Remove coin from animated cache to stop rendering
            let layer = this.world.terrain.layers[coinLayer];
            if (layer.animated) {
              layer.animated.forEach((animatedTile) => {
                if (animatedTile.id == "17") {
                  // coin tile id
                  animatedTile.positions = animatedTile.positions.filter(
                    (pos) => !(pos.x === cat.target.x && pos.y === cat.target.y),
                  );
                }
              });
            }

            // Add bonus points for collecting coin
            gameScore += 100;
            updateHUD();

            // Farcade SDK: Haptic feedback for collecting coin
            if (window.FarcadeSDK) {
              window.FarcadeSDK.singlePlayer.actions.hapticFeedback();
            }

            // Play coin collection sound
            if (this.world.assets.audio.coin_collect && this.world.assets.audio.coin_collect.audio) {
              try {
                this.world.assets.audio.coin_collect.audio.currentTime = 0;
                this.world.assets.audio.coin_collect.audio.play().catch((e) => {
                  console.log("Could not play coin collection sound:", e);
                });
              } catch (error) {
                console.log("Error playing coin sound:", error);
              }
            }
          }
        });
      };

      inGame.checkWin = function () {
        if (this.cats.length === 0) {
          // No cats left - Game Over (this should not normally be reached
          // since individual cat death now triggers immediate game over)
          hideHUD();
          stopAllMusic();
          console.log("GAME OVER - All pirates lost - Final Score:", gameScore);

          // Farcade SDK: Report game over with score
          if (window.FarcadeSDK) {
            window.FarcadeSDK.singlePlayer.actions.gameOver({
              score: gameScore,
            });
          }

          // Reset game to level 1 for next play
          this.world.current_level = 1;
          resetGame();

          // Return to menu
          this.world.startScene("menu");
          return false;
        }
        let win = this.cats.every((cat) => {
          let tile = this.world.getTile(3, cat.target.x, cat.target.y);
          return tile.name == "exit";
        });
        if (win === true && this.cats.length >= this.world.findTile(3, 8).length && !this.won) {
          this.won = true;

          // Play exit sound when reaching the portal (not selection sound)
          if (this.world.assets.audio.exit && this.world.assets.audio.exit.audio) {
            try {
              this.world.assets.audio.exit.audio.currentTime = 0;
              this.world.assets.audio.exit.audio.play().catch((e) => {
                console.log("Could not play exit audio:", e);
              });
            } catch (error) {
              console.log("Error playing exit sound:", error);
            }
          } else {
            console.log("Exit audio not available");
          }

          // Level completed - calculate and add score
          levelCompleted(this.world);

          if (this.world.maps["map_" + (this.world.current_level + 1)] !== undefined) {
            this.transition.start(0, Math.max(this.world.W / 2, this.world.H / 2), () => {
              this.world.current_level += 1;
              this.world.startScene("inGame");
            });
          } else {
            // All levels completed - capture final score and reset game
            this.transition.start(0, Math.max(this.world.W / 2, this.world.H / 2), () => {
              hideHUD();
              stopAllMusic(); // Stop background music
              console.log("GAME COMPLETED - All levels finished - Final Score:", gameScore);

              // Farcade SDK: Report game completion with final score
              if (window.FarcadeSDK) {
                window.FarcadeSDK.singlePlayer.actions.gameOver({
                  score: gameScore,
                });
              }

              // Reset game to level 1 for next play
              this.world.current_level = 1;
              resetGame();

              // Return to menu (menu will start its own music)
              this.world.startScene("menu");
            });
          }
        }
      };
      // destroy itself when animation is finish
      class Effect extends Entity {
        constructor(scene, sprite_data, x, y, callback) {
          super(scene, x * scene.world.tile_size, y * scene.world.tile_size);
          this.setSprite(sprite_data);
          this.sprite.addAnimation("full", sprite_data.frames);
          this.sprite.speed = 0.4;
          this.sprite.offset.y = -3;
          this.trigger = sprite_data.frames.length;
          this.callback = callback || undefined;
        }
        render() {
          if (this.sprite.current_frame + 1 === this.trigger) {
            if (this.callback !== undefined) {
              this.callback();
              this.callback = undefined;
            }
          }
          if (this.sprite.current_frame + 1 === this.sprite.animations[this.sprite.current_animation].length) {
            this.scene.effects.splice(this.scene.effects.indexOf(this), 1);
          }
          this.sprite.animate("full");
          this.display();
        }
      }
      class Cat extends Entity {
        constructor(scene, x, y) {
          super(scene, x * scene.world.tile_size, y * scene.world.tile_size);
          this.old_position = new Vector(x, y);
          this.target = new Vector(x, y);
          this.canBeControlled = true;
          this.inTranslation = false;
          this.lastDirection = new Vector(0, 0);
          this.isDead = false;
          // Trasnlation of the cat when they move
          this.transition = {
            start: new Date(),
            duration: 300,
            type: Util.easeInOutQuad,
            start_pos: new Vector(),
          };
        }
        // apply translation on cat when necessary
        translation() {
          if (this.inTranslation) {
            // get current time !
            let time = new Date() - this.transition.start;
            if (time < this.transition.duration) {
              let x = this.transition.type(
                  time,
                  this.transition.start_pos.x,
                  this.transition.target.x - this.transition.start_pos.x,
                  this.transition.duration,
                ),
                y = this.transition.type(
                  time,
                  this.transition.start_pos.y,
                  this.transition.target.y - this.transition.start_pos.y,
                  this.transition.duration,
                );
              this.body.position = new Vector(x, y);
            } else {
              // apply position when translation is finish :) !
              this.old_position = this.target.copy();
              let next_move = this.target.copy();
              next_move.mult(this.world.tile_size);
              this.body.position = next_move;
              this.inTranslation = false;
              if (this.isDead) {
                // delete cat
                let spawn_data = {
                  image: "water_splash",
                  frames: [0, 1, 2, 3, 4, 5, 6, 7, 8],
                  size: {
                    x: 20,
                    y: 32,
                  },
                };
                let spawn_effect = new Effect(this.scene, spawn_data, this.target.x, this.target.y - 1, () => {
                  this.scene.cats.splice(this.scene.cats.indexOf(this), 1);
                  this.world.assets.audio.splash.audio.play();

                  // Farcade SDK: Haptic feedback for falling in water
                  if (window.FarcadeSDK) {
                    window.FarcadeSDK.singlePlayer.actions.hapticFeedback();
                  }

                  // Game Over immediately when ANY pirate falls into water
                  hideHUD();
                  stopAllMusic(); // Stop background music
                  console.log("GAME OVER - Pirate fell into water - Final Score:", gameScore);

                  // Farcade SDK: Report game over with score
                  if (window.FarcadeSDK) {
                    window.FarcadeSDK.singlePlayer.actions.gameOver({
                      score: gameScore,
                    });
                  }

                  // Reset game to level 1 for next play
                  this.world.current_level = 1;
                  resetGame();

                  // Return to menu (menu will start its own music)
                  this.world.startScene("menu");
                });
                spawn_effect.sprite.offset.y = 0;
                spawn_effect.trigger = 2;
                this.scene.effects.push(spawn_effect);
              }
              if (this.canBeControlled === false) {
                this.move(this.lastDirection.x, this.lastDirection.y);
                this.scene.collisionCats();
                this.applyMove();
              } else {
                // check arrows
                let current_tile = this.world.getTile(3, this.target.x, this.target.y);
                switch (current_tile.name) {
                  case "arrowRight":
                    this.move(1, 0);
                    this.scene.collisionCats();
                    this.applyMove();
                    break;
                  case "arrowLeft":
                    this.move(-1, 0);
                    this.scene.collisionCats();
                    this.applyMove();
                    break;
                  case "arrowUp":
                    this.move(0, -1);
                    this.scene.collisionCats();
                    this.applyMove();
                    break;
                  case "arrowDown":
                    this.move(0, 1);
                    this.scene.collisionCats();
                    this.applyMove();
                    break;
                  default:
                }
              }
              // check if we won when a cat finish a step
              this.scene.checkWin();
              this.scene.collisionCoins(); // Check for coin collection after movement
            }
          }
        }
        move(x, y) {
          this.target = this.old_position.copy();
          let direction = new Vector(x, y);
          // get future position
          let future_position = this.target.copy();
          future_position.add(direction);
          let layers = this.world.terrain.layers;
          let future_tile = layers.map((layer) => {
            let index = layers.indexOf(layer);
            return this.world.getTile(index, future_position.x, future_position.y);
          });
          let collision = future_tile.every((tile) => {
            if (tile == false) {
              return tile == false;
            } else {
              return tile.collision === false;
            }
          });
          if (collision == true) {
            this.target.add(direction);
          }
          if (future_tile[3].name === "ice") {
            this.canBeControlled = false;
            this.transition.type = Util.linearTween;
            this.transition.duration = 100;
            return false;
          }
          if (future_tile[3].name === "trap") {
            let dust_data = {
              image: "dust_effect",
              frames: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12],
              size: {
                x: 32,
                y: 32,
              },
            };
            let dust_effect = new Effect(this.scene, dust_data, this.target.x, this.target.y);
            this.scene.effects.push(dust_effect);
            this.world.assets.audio.eboulement.audio.play();

            this.world.terrain.layers[3].geometry[future_position.y][future_position.x] = 10;
            // cache the map
            this.world.terrainCache(this.world.terrain.layers[3]);
            return false;
          }
          if (future_tile[1].name !== "ground") {
            this.transition.type = Util.easeInOutQuad;
            this.transition.duration = 200;
            this.isDead = true;
            return false;
          } else {
            this.canBeControlled = true;
            this.transition.type = Util.easeInOutQuad;
            this.transition.duration = 200;
            return false;
          }
        }
        applyMove() {
          // prevent cat to move if his target equal his actual position :V
          if (this.old_position.x === this.target.x && this.old_position.y === this.target.y) {
            this.canBeControlled = true;
            return false;
          }
          this.lastDirection = new Vector(this.target.x - this.old_position.x, this.target.y - this.old_position.y);
          this.shouldMove = false;
          this.transition.start_pos = this.old_position.copy();
          this.transition.start_pos.mult(this.world.tile_size);
          this.transition.target = this.target.copy();
          this.transition.target.mult(this.world.tile_size);
          this.transition.start = new Date();
          this.inTranslation = true;
        }
        checkOthers() {
          let others = this.scene.cats;
          let result = false;
          for (let i = 0; i < others.length; i++) {
            if (this === others[i]) continue;
            if (others[i].target.x === this.target.x && others[i].target.y === this.target.y) {
              result = true;
              break;
            }
          }
          return result;
        }
      }
      // Controls scene removed - not needed since we only use Arrow Keys + Space

      let game = new Diorama(parameters);
      // global variables
      game.current_level = 1;

      // Create dynamic UI elements
      createGameHUD();
      createControlPad();

      // Add the different scenes here
      // the addScene function link the scene with the world (game)
      game.addScene(menu);
      game.addScene(levels);
      // game.addScene(controls); // Removed - not needed
      game.addScene(inGame);
      game.ready();
      // everything start being loaded now !
      // the ready function must be called last !

      // Initialize control pad visibility on page load
      updateControlPadVisibility("menu");

      // Update control pad visibility on window resize (for device rotation)
      window.addEventListener("resize", function () {
        // Add a small delay to ensure the resize is complete
        setTimeout(() => {
          const currentScene = game && game.current_scene ? game.current_scene.name : "menu";

          // Recreate control pad with new dimensions for mobile devices
          recreateControlPad();

          // Recreate overlays with new dimensions for mobile devices
          recreateMenuOverlay();
          recreateLevelsOverlay();
          recreateInstructionsOverlay();

          // Update visibility and positions based on current scene
          updateControlPadVisibility(currentScene);
          updateMenuOverlay();
          updateLevelsOverlay();
          updateInstructionsOverlay();
        }, 100);
      });

      // Farcade SDK: Game is ready to play
      if (window.FarcadeSDK) {
        window.FarcadeSDK.singlePlayer.actions.ready();

        // Handle play again requests
        window.FarcadeSDK.on("play_again", () => {
          console.log("PLAY AGAIN: Starting play again sequence");

          // Reset game state and start new game
          game.current_level = 1;
          resetGame(); // Use the resetGame function to reset score and timer

          console.log("PLAY AGAIN: About to start menu scene");
          game.startScene("menu");
          console.log("PLAY AGAIN: Menu scene started");
        });

        // Handle mute/unmute toggle
        window.FarcadeSDK.on("toggle_mute", (data) => {
          // Set game audio based on data.isMuted
          if (data.isMuted) {
            game.soundLevel(0);
            stopAllMusic();
          } else {
            game.soundLevel(0.1);
            // Resume appropriate music based on current scene
            if (game.current_scene && game.current_scene.name === "menu") {
              ensureMenuMusicPlaying();
            } else if (game.current_scene && game.current_scene.name === "inGame") {
              ensurePirateMusicPlaying();
            }
          }
        });
      }

      // Making the game full screen and with a softer audio volume by default
      game.soundLevel(0.1);
      game.fullScreen();

      // Initialize overlay systems
      createMenuOverlay();
      createLevelsOverlay();
      createInstructionsOverlay();
    </script>
  </body>
</html>
