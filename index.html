<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Opensea Drop</title>
    <!-- Farcade SDK -->
    <script src="https://cdn.jsdelivr.net/npm/@farcade/game-sdk@latest/dist/index.min.js"></script>
    <!-- Google Fonts - Pirate/Adventure Style Font -->
    <link
      href="https://fonts.googleapis.com/css2?family=Pirata+One&family=Creepster&family=Jolly+Lodger&display=swap"
      rel="stylesheet"
    />
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        height: 100%;
      }
      body {
        color: white;
        background-color: #000;
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: hidden;
      }
      canvas {
        flex-shrink: 0;
        background-color: #000;
        object-fit: contain;
        image-rendering: auto;
      }
      .crisp {
        image-rendering: auto;
      }

      /* Canvas styles */
      canvas {
        image-rendering: pixelated;
        image-rendering: -moz-crisp-edges;
        image-rendering: crisp-edges;
        touch-action: none; /* Disable default touch behaviors */
        user-select: none; /* Prevent text selection on touch */
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
      }

      /* Touch feedback for mobile */
      .touch-feedback {
        position: fixed;
        width: 50px;
        height: 50px;
        border-radius: 50%;
        background: rgba(255, 215, 0, 0.3);
        border: 2px solid rgba(255, 215, 0, 0.6);
        pointer-events: none;
        z-index: 999;
        transform: translate(-50%, -50%);
        animation: touchFeedback 0.3s ease-out;
        display: none;
      }

      @keyframes touchFeedback {
        0% {
          transform: translate(-50%, -50%) scale(0.5);
          opacity: 1;
        }
        100% {
          transform: translate(-50%, -50%) scale(1.5);
          opacity: 0;
        }
      }

      /* Menu Play Button Overlay */
      #menuPlayButton {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -25%);
        background: transparent;
        border: none;
        color: #ffd700;
        font-family: "Pirata One", sans-serif;
        font-size: 36px;
        text-shadow: 3px 3px 0px #8b4513;
        cursor: pointer;
        padding: 15px 30px;
        z-index: 1000;
        display: none; /* Hidden by default */
        outline: none;
        -webkit-tap-highlight-color: transparent;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        /* Ensure it's above canvas */
        pointer-events: auto;
        /* Add pulsing animation similar to the original */
        animation: playButtonPulse 3s ease-in-out infinite;
      }

      @keyframes playButtonPulse {
        0% {
          color: #b8860b;
          text-shadow: 2px 2px 0px #2f1b14;
        }
        50% {
          color: #ffd700;
          text-shadow: 3px 3px 0px #8b4513;
        }
        100% {
          color: #b8860b;
          text-shadow: 2px 2px 0px #2f1b14;
        }
      }

      #menuPlayButton:active {
        transform: translate(-50%, -25%) scale(0.95);
        color: #b8860b;
        text-shadow: 2px 2px 0px #2f1b14;
        animation: none; /* Stop pulsing when pressed */
      }

      /* HUD Styles - Responsive HTML elements */
      #gameHUD {
        position: fixed;
        top: 25px;
        left: 10px;
        right: 10px;
        display: none;
        z-index: 1000;
        pointer-events: none;
      }

      .hud-container {
        display: flex;
        justify-content: center;
        gap: 80px;
        align-items: flex-start;
        width: 100%;
        max-width: 800px;
        margin: 0 auto;
        padding: 0 20px;
        box-sizing: border-box;
      }

      .hud-left {
        display: flex;
        flex-direction: column;
        align-items: flex-start;
      }

      .hud-right {
        display: flex;
        flex-direction: column;
        align-items: flex-end;
      }

      .score-display,
      .timer-display {
        font-family: "Pirata One", serif;
        font-size: clamp(20px, 6vw, 40px);
        color: #ffffff;
        text-shadow: 3px 3px 0px rgba(0, 0, 0, 0.8);
        margin: 5px 0;
        line-height: 1;
      }

      .surrender-button {
        background: url("https://i.postimg.cc/KYTPr4CY/redbutton.png") no-repeat
          center;
        background-size: contain;
        width: clamp(45px, 10vw, 70px);
        height: clamp(45px, 10vw, 70px);
        border: none;
        cursor: pointer;
        pointer-events: auto;
        transition: transform 0.1s;
        margin-top: 7px;
      }

      .surrender-button:hover {
        transform: scale(1.1);
      }

      .surrender-button:active {
        transform: scale(0.95);
      }

      #hudCanvas {
        display: none;
      }

      /* Hints Styles - Responsive HTML elements */
      #gameHints {
        position: fixed;
        bottom: 40px;
        left: 50%;
        transform: translateX(-50%);
        display: none;
        z-index: 1000;
        pointer-events: none;
      }

      .hints-container {
        background: rgba(0, 0, 0, 0.7);
        border-radius: 10px;
        padding: 15px 25px;
        max-width: 95vw;
        text-align: center;
        overflow: hidden;
      }

      .hint-text {
        font-family: "Pirata One", serif;
        font-size: clamp(20px, 5vw, 40px);
        color: #ffffff;
        text-shadow: 2px 2px 0px rgba(0, 0, 0, 0.8);
        margin: 0;
        line-height: 1.2;
        opacity: 0;
        transition: opacity 0.3s ease-in-out;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .hint-text.visible {
        opacity: 1;
      }

      #hintsCanvas {
        display: none;
      }

      /* Responsive adjustments */
      @media (max-width: 600px) {
        .hud-container {
          padding: 0 10px;
        }

        .hints-container {
          padding: 10px 15px;
          margin: 0 10px;
        }
      }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/@farcade/game-sdk@latest/dist/index.min.js"></script>
  </head>
  <body>
    <!-- Game HUD - Score, Timer and Surrender Button -->
    <div id="gameHUD">
      <div class="hud-container">
        <div class="hud-left">
          <div class="score-display">Score: <span id="scoreValue">0</span></div>
          <div class="timer-display">Time: <span id="timerValue">30</span></div>
        </div>
        <div class="hud-right">
          <button
            class="surrender-button"
            id="surrenderBtn"
            title="Surrender"
          ></button>
        </div>
      </div>
    </div>

    <!-- Game Hints - Rotating hints at bottom -->
    <div id="gameHints">
      <div class="hints-container">
        <p class="hint-text" id="hintText">Take all the coins, or not...</p>
      </div>
    </div>

    <!-- Menu Play Button Overlay -->
    <button id="menuPlayButton">PLAY</button>

    <!-- Touch feedback indicator -->
    <div id="touchFeedback" class="touch-feedback"></div>

    <script>
      // ----------
      // Utility
      // ----------
      Util = {};
      Util.timeStamp = function () {
        return window.performance.now();
      };
      Util.random = function (min, max) {
        return min + Math.random() * (max - min);
      };
      Util.array2D = function (tableau, largeur) {
        var result = [];
        for (var i = 0; i < tableau.length; i += largeur)
          result.push(tableau.slice(i, i + largeur));
        return result;
      };
      Util.toDio = function (array) {
        let tab = array.map((x) => {
          if (x !== 0) {
            return x - 1;
          } else {
            return x;
          }
        });
        let render = Util.array2D(tab, 16);
        return JSON.stringify(render);
      };
      Util.map = function (a, b, c, d, e) {
        return ((a - b) / (c - b)) * (e - d) + d;
      };
      Util.lerp = function (value1, value2, amount) {
        return value1 + (value2 - value1) * amount;
      };
      Util.linearTween = function (
        currentTime,
        start,
        degreeOfChange,
        duration
      ) {
        return (degreeOfChange * currentTime) / duration + start;
      };
      Util.easeInOutQuad = function (t, b, c, d) {
        t /= d / 2;
        if (t < 1) return (c / 2) * t * t + b;
        t--;
        return (-c / 2) * (t * (t - 2) - 1) + b;
      };
      Util.easeInOutExpo = function (t, b, c, d) {
        t /= d / 2;
        if (t < 1) return (c / 2) * Math.pow(2, 10 * (t - 1)) + b;
        t--;
        return (c / 2) * (-Math.pow(2, -10 * t) + 2) + b;
      };

      // ----------
      // Scene
      // ----------
      class Scene {
        constructor(name) {
          this.name = name;
          this.loop = true;
          this.init_once = false;
        }
        giveWorld(world) {
          this.world = world;
          this.ctx = world.ctx;
        }
        keyEvents(event) {}
        init() {}
        render() {}
        addEntity() {}
      }
      class Entity {
        constructor(scene, x, y) {
          this.scene = scene;
          this.world = scene.world;
          this.ctx = this.world.ctx;
          this.body = new Body(this, x, y);
        }
        setSprite(sprite_data) {
          this.sprite = new Sprite(this, sprite_data);
        }
        display() {
          if (this.playerSprite !== undefined) {
            this.playerSprite.display();
          } else if (this.sprite === undefined) {
            this.ctx.strokeStyle = "#000";
            this.ctx.strokeRect(
              this.body.position.x,
              this.body.position.y,
              this.body.size.x,
              this.body.size.y
            );
          } else {
            this.sprite.display();
          }
        }
        integration() {
          this.body.integration();
        }
      }

      // class for animated sprites !
      class Sprite {
        constructor(entity, sprite_data) {
          this.entity = entity;
          this.world = this.entity.world;
          this.tile_size = this.world.tile_size;
          this.ctx = this.world.ctx;
          // image data
          this.image = this.world.assets.image[sprite_data.image].image;
          // sprite
          this.size = sprite_data.size;
          this.current_frame = 0;
          this.animations = {};
          this.current_animation = undefined;
          this.width = this.image.width / this.size.x;
          this.height = this.image.height / this.size.y;
          // timer
          this.tick = 0;
          this.speed = 0.2;
          // offset
          this.offset = {
            x: 0,
            y: 0,
          };
        }
        addAnimation(name, frames) {
          this.animations[name] = frames;
          this.current_animation = name;
        }
        animate(animation_name) {
          this.current_animation = animation_name;
          if (this.tick < 1) {
            this.tick += this.speed;
          } else {
            this.tick = 0;
            if (
              this.current_frame <
              this.animations[animation_name].length - 1
            ) {
              this.current_frame += 1;
            } else {
              this.current_frame = 0;
            }
          }
        }
        display() {
          this.ctx.drawImage(
            this.image,
            Math.floor(
              this.animations[this.current_animation][this.current_frame] %
                this.width
            ) * this.size.x,
            Math.floor(
              this.animations[this.current_animation][this.current_frame] /
                this.width
            ) * this.size.y,
            this.size.x,
            this.size.y,
            this.entity.body.position.x +
              (this.tile_size / 2 - this.size.x / 2) +
              this.offset.x,
            this.entity.body.position.y +
              (this.tile_size / 2 - this.size.x / 2) +
              this.offset.y,
            this.size.x,
            this.size.y
          );
        }
      }

      // PlayerSprite class for managing multiple sprites and states
      class PlayerSprite {
        constructor(entity, idle_sprite_data, walk_sprite_data) {
          this.entity = entity;
          this.world = this.entity.world;
          this.ctx = this.world.ctx;

          // Create sprites for different states
          this.idleSprite = new Sprite(entity, idle_sprite_data);
          this.walkSprite = new Sprite(entity, walk_sprite_data);

          // Setup animations
          this.setupAnimations();

          // Current state
          this.currentState = "idle";
          this.currentSprite = this.idleSprite;

          // Movement tracking
          this.isMoving = false;
          this.lastPosition = {
            x: entity.body.position.x,
            y: entity.body.position.y,
          };
        }

        setupAnimations() {
          // Idle animation: 6 frames (192x32, so each frame is 32x32)
          this.idleSprite.addAnimation("idle", [0, 1, 2, 3, 4, 5]);
          this.idleSprite.speed = 0.15;

          // Walk animation: 12 frames (384x32, so each frame is 32x32)
          this.walkSprite.addAnimation(
            "walk",
            [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
          );
          this.walkSprite.speed = 0.25;
        }

        updateMovementState() {
          // Check if entity is moving by comparing positions
          const currentPos = this.entity.body.position;
          const hasPositionChanged =
            Math.abs(currentPos.x - this.lastPosition.x) > 0.1 ||
            Math.abs(currentPos.y - this.lastPosition.y) > 0.1;

          // Update movement state based on translation status
          if (this.entity.inTranslation) {
            this.isMoving = true;
          } else {
            this.isMoving = false;
          }

          // Update last position
          this.lastPosition = { x: currentPos.x, y: currentPos.y };
        }

        animate() {
          this.updateMovementState();

          // Switch states based on movement
          const newState = this.isMoving ? "walk" : "idle";

          if (newState !== this.currentState) {
            this.currentState = newState;
            this.currentSprite =
              newState === "walk" ? this.walkSprite : this.idleSprite;
          }

          // Animate current sprite
          if (this.currentState === "idle") {
            this.currentSprite.animate("idle");
          } else {
            this.currentSprite.animate("walk");
          }
        }

        display() {
          this.currentSprite.display();
        }

        // Proxy methods for compatibility
        set offset(value) {
          this.idleSprite.offset = value;
          this.walkSprite.offset = value;
        }

        get offset() {
          return this.currentSprite.offset;
        }

        set speed(value) {
          this.idleSprite.speed = value;
          this.walkSprite.speed = value;
        }
      }

      class Body {
        constructor(entity, x, y) {
          this.world = entity.world;
          this.step = this.world.FPS.step;
          this.position = new Vector(x, y);
          this.next_position = new Vector(x, y);
          this.velocity = new Vector(0, 0);
          this.stepped_velocity = new Vector(0, 0);
          this.acceleration = new Vector(0, 0);
          this.drag = 0.98;
          this.size = {
            x: 16,
            y: 16,
          };
        }
        setSize(x, y) {
          this.size.x = x;
          this.size.y = y;
        }
        updateVelocity() {
          this.velocity.add(this.acceleration);
          this.velocity.mult(this.drag);
          this.stepped_velocity = this.velocity.copy();
          this.stepped_velocity.mult(this.step);
          this.next_position = this.position.copy();
          this.next_position.add(this.stepped_velocity);
          // reset acceleration
          this.acceleration.mult(0);
        }
        updatePosition() {
          this.position.add(this.stepped_velocity);
        }
        integration() {
          this.updateVelocity();
          this.updatePosition();
        }
        applyForce(force_vector) {
          this.acceleration.add(force_vector);
        }
      }

      class Vector {
        constructor(x, y) {
          this.x = x || 0;
          this.y = y || 0;
        }
        set(x, y) {
          this.x = x;
          this.y = y;
        }
        add(vector) {
          this.x += vector.x;
          this.y += vector.y;
        }
        sub(vector) {
          this.x -= vector.x;
          this.y -= vector.y;
        }
        mult(scalar) {
          this.x *= scalar;
          this.y *= scalar;
        }
        div(scalar) {
          this.x /= scalar;
          this.y /= scalar;
        }
        limit(limit_value) {
          if (this.mag() > limit_value) this.setMag(limit_value);
        }
        mag() {
          return Math.hypot(this.x, this.y);
        }
        setMag(new_mag) {
          if (this.mag() > 0) {
            this.normalize();
          } else {
            this.x = 1;
            this.y = 0;
          }
          this.mult(new_mag);
        }
        dist(vector) {
          return new Vector(this.x - vector.x, this.y - vector.y).mag();
        }
        normalize() {
          let mag = this.mag();
          if (mag > 0) {
            this.x /= mag;
            this.y /= mag;
          }
        }
        heading() {
          return Math.atan2(this.x, this.y);
        }
        setHeading(angle) {
          let mag = this.mag();
          this.x = Math.cos(angle) * mag;
          this.y = Math.sin(angle) * mag;
        }
        copy() {
          return new Vector(this.x, this.y);
        }
      }

      class Box {
        constructor(world, box_data) {
          this.world = world;
          this.ctx = world.ctx;
          this.c_ctx = world.c_ctx;
          this.box_data = box_data;
          this.resolution = box_data.resolution;
          this.image = world.assets.image[box_data.image].image;
        }
        display(x, y, width, height) {
          // background
          this.ctx.fillRect(x + 1, y + 1, width - 2, height - 2);
          // corners
          this.ctx.lineWidth = 2;
          let coners = [0, 2, 6, 8];
          for (let i = 0; i < 4; i++) {
            let pos_x = x + Math.floor(i % 2) * (width - this.resolution),
              pos_y = y + Math.floor(i / 2) * (height - this.resolution);
            let clip_x = Math.floor(i % 2) * (this.resolution * 2),
              clip_y = Math.floor(i / 2) * (this.resolution * 2);
            this.ctx.drawImage(
              this.image,
              clip_x,
              clip_y,
              this.resolution,
              this.resolution,
              pos_x,
              pos_y,
              this.resolution,
              this.resolution
            );
          }
          let offset = this.resolution * 3;
          // top
          this.ctx.drawImage(
            this.image,
            8,
            0,
            this.resolution,
            this.resolution,
            x + 8,
            y,
            this.resolution + width - offset,
            this.resolution
          );
          // bottom
          this.ctx.drawImage(
            this.image,
            8,
            16,
            this.resolution,
            this.resolution,
            x + 8,
            y + height - this.resolution,
            this.resolution + width - offset,
            this.resolution
          );
          // left
          this.ctx.drawImage(
            this.image,
            0,
            8,
            this.resolution,
            this.resolution,
            x,
            y + 8,
            this.resolution,
            this.resolution + height - offset
          );
          // right
          this.ctx.drawImage(
            this.image,
            16,
            8,
            this.resolution,
            this.resolution,
            x + width - this.resolution,
            y + this.resolution,
            this.resolution,
            this.resolution + height - offset
          );
        }
      }
      // ----------
      // Diorama.js Engine
      // ----------
      class Diorama {
        constructor(parameters) {
          this.parameters = parameters;
          // Game and author's name
          this.game_info = {
            name: parameters.name || "Untitled",
            author: parameters.author || "Anonymous",
          };
          // canvas
          this.background_color = parameters.background_color || "#000";
          this.initCanvas(parameters);
          // Assets
          this.counter = 0;
          this.toLoad = parameters.assets.length;
          this.assets = {
            image: {},
            audio: {},
          };
          this.audio_muted = false;
          // keyboard event
          this.keys = {};
          // Scenes
          this.scenes = {};
          this.start_screen = parameters.start_screen || undefined;
          this.current_scene = "";
          // Bitmap font Data
          this.alphabet =
            "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ?!:',.()<>[]";
          this.fonts = {};
          // Maps
          this.tile_size = parameters.tile_size || 16;
          this.tiles_data = {};
          if (parameters.tiles !== undefined) {
            parameters.tiles.map((tile) => {
              this.tiles_data[tile.id] = tile;
            });
          }
          this.mapsMax = parameters.maps.length;
          this.maps = {};
          if (parameters.maps !== undefined) {
            parameters.maps.map((map) => {
              this.maps[map.name] = map;
            });
          }
          // Box system
          this.boxes = {};
          // By default the current font is the first font you create
          this.currentFont = undefined;
          // Game loop Data
          this.FPS = {
            now: 0,
            delta: 0,
            last: Util.timeStamp(),
            step: 1 / (parameters.frame_rate || 60),
          };
          this.requestChange = {
            value: false,
            action: "",
          };
          this.main_loop = undefined;
        }
        // ---
        // Setup & Loading
        // ---
        ready() {
          this.loadAssets(this.parameters.assets);
        }
        initCanvas(parameters) {
          this.canvas = document.createElement("canvas");
          this.ctx = this.canvas.getContext("2d");
          this.W = this.canvas.width = parameters.width || 256;
          this.H = this.canvas.height = parameters.height || 256;
          this.scale = parameters.scale || 1;
          this.full = false;
          this.ctx.imageSmoothingEnabled = true;
          this.canvas.classList.add("crisp");
          document.body.appendChild(this.canvas);
          // cache canvas
          this.cache = document.createElement("canvas");
          this.c_ctx = this.cache.getContext("2d");
        }
        loader() {
          // increment loader
          this.clear("#222");
          this.counter += 1;
          let padding = 20;
          let width = this.W - padding * 2,
            x = padding,
            y = this.H - padding * 2;
          this.ctx.fillStyle = "#111";
          this.ctx.fillRect(x, y, width, 20);
          this.ctx.fillStyle = "#333";
          this.ctx.fillRect(x, y, (this.counter * width) / this.toLoad, 20);
          this.ctx.strokeStyle = "#000";
          this.ctx.lineWidth = 4;
          this.ctx.strokeRect(x, y, width, 20);
          if (this.counter === this.toLoad) {
            this.launch();
          }
        }
        loadAssets(assets) {
          if (assets === undefined) console.log("Nothing to load");
          assets.map((obj) => this.checkAssets(obj));
        }
        checkAssets(obj) {
          let subject = obj;
          switch (obj.type) {
            case "img":
              let img = new Image();
              img.onload = () => {
                this.loader();
              };
              img.onerror = () => {
                console.log("can't load Image: " + obj.name);
              };
              img.src = obj.path;
              subject.image = img;
              this.assets.image[obj.name] = subject;
              break;
            case "audio":
              let audio = new Audio(obj.path);
              audio.addEventListener("canplaythrough", this.loader());
              audio.onerror = () => {
                console.log("can't load audio: " + obj.name);
              };
              subject.audio = audio;
              this.assets.audio[obj.name] = subject;
              break;
            case undefined:
              console.log(obj.name, " doesn't have any type");
              break;
            default:
              console.log(obj.name, " has a none known type");
          }
        }
        launch() {
          this.eventSetup();
          this.initBoxes(this.parameters.boxes);
          this.initFonts(this.parameters.fonts);
          this.startScene(this.start_screen);
        }
        initBoxes(boxes_data) {
          if (boxes_data === undefined) return false;
          boxes_data.map((box) => {
            this.boxes[box.name] = new Box(this, box);
          });
        }
        drawBox(box_name, x, y, width, height) {
          this.boxes[box_name].display(x, y, width, height);
        }
        // ---
        // Font manager
        // ---
        setFont(font_name) {
          this.currentFont = font_name;
        }
        initFonts(fonts_data) {
          if (fonts_data === undefined && fonts_data.length > 0) return false;
          fonts_data.map((font) => {
            if (this.assets.image[font.image] === undefined) {
              console.log("can't load font, " + font.image + " doesn't exist");
              return false;
            }
            font.image = this.assets.image[font.image].image;
            this.fonts[font.name] = font;
          });
          // set current font to the first font !
          this.currentFont = Object.keys(this.fonts)[0];
        }
        write(text, x, y, justify, colorID) {
          if (this.currentFont === undefined) {
            console.log("No bitmap_font");
            return false;
          }
          if (typeof justify === "string") {
            switch (justify) {
              case "center":
                x -= (text.length * this.fonts[this.currentFont].size.x) / 2;
                break;
              case "right":
                x -= text.length * this.fonts[this.currentFont].size.x;
                break;
              default:
            }
            this.writeLine(text, x, y, colorID || 0);
          } else {
            this.writeParagraph(text, x, y, justify, colorID || 0);
          }
        }
        writeParagraph(text, x, y, justify, colorID) {
          let y_offset = 0,
            line_height = this.fonts[this.currentFont].size.y + 5,
            size_x = this.fonts[this.currentFont].size.x,
            words = text.split(" "),
            line = "";
          for (let i = 0; i < words.length; i++) {
            line += words[i] + " ";
            let nextword_width = 0,
              next_word = words[i + 1],
              line_length = line.length * size_x;
            next_word ? (nextword_width = next_word.length * size_x) : 0;
            if (line_length + nextword_width > justify) {
              this.writeLine(line, x, y + y_offset, 0, colorID);
              y_offset += line_height;
              line = "";
            } else {
              this.writeLine(line, x, y + y_offset, 0, colorID);
            }
          }
        }
        writeLine(text, x, y, colorID) {
          // write line
          let size_x = this.fonts[this.currentFont].size.x,
            size_y = this.fonts[this.currentFont].size.y,
            font_img = this.fonts[this.currentFont].image;
          for (let i = 0; i < text.length; i++) {
            let index = this.alphabet.indexOf(text.charAt(i)),
              clipX = size_x * index,
              posX = x + i * size_x;
            this.ctx.drawImage(
              font_img,
              clipX,
              colorID * size_y,
              size_x,
              size_y,
              posX,
              y,
              size_x,
              size_y
            );
          }
        }
        // -----------------
        // Events
        // -----------------
        eventSetup() {
          document.addEventListener(
            "keydown",
            (event) => this.keyDown(event),
            false
          );
          document.addEventListener(
            "keyup",
            (event) => this.keyUp(event),
            false
          );

          // Add mouse and touch events for mobile support
          this.canvas.addEventListener(
            "click",
            (event) => this.mouseEvent(event),
            false
          );

          // Add swipe gesture support for mobile movement
          this.canvas.addEventListener(
            "touchstart",
            (event) => this.touchStart(event),
            false
          );
          this.canvas.addEventListener(
            "touchmove",
            (event) => this.touchMove(event),
            false
          );
          this.canvas.addEventListener(
            "touchend",
            (event) => this.touchEnd(event),
            false
          );

          // Touch tracking variables
          this.touchStartX = 0;
          this.touchStartY = 0;
          this.touchEndX = 0;
          this.touchEndY = 0;
          this.minSwipeDistance = 20; // Reduced from 30 to 20 for more sensitive swipes
          this.holdTimer = null;
          this.continuousTimer = null;
          this.isHolding = false;
        }
        keyDown(event) {
          event.preventDefault();
          this.keys[event.code] = true;
          // Only allow Arrow Keys and Space - remove F and M key handling
          this.current_scene.keyEvents(event);
        }
        keyUp(event) {
          event.preventDefault();
          this.keys[event.code] = false;
        }

        // Touch event handlers for improved mobile controls
        touchStart(event) {
          event.preventDefault();
          const touch = event.touches[0];
          this.touchStartX = touch.clientX;
          this.touchStartY = touch.clientY;
          this.touchStartTime = Date.now();
          this.isHolding = false;
          this.lastMoveTime = 0;
          this.moveRepeatDelay = 150; // Reduced from 200ms - faster initial response
          this.moveRepeatRate = 120; // Reduced from 150ms - faster continuous movement

          // Show touch feedback
          this.showTouchFeedback(this.touchStartX, this.touchStartY);

          // Start hold detection timer
          this.holdTimer = setTimeout(() => {
            this.isHolding = true;
            this.startContinuousMovement();
          }, 150); // Reduced from 200ms - start continuous movement faster

          console.log("Touch start:", this.touchStartX, this.touchStartY);
        }

        showTouchFeedback(x, y) {
          const feedback = document.getElementById("touchFeedback");
          if (feedback) {
            feedback.style.left = x + "px";
            feedback.style.top = y + "px";
            feedback.style.display = "block";

            // Hide after animation
            setTimeout(() => {
              feedback.style.display = "none";
            }, 300);
          }
        }

        touchMove(event) {
          event.preventDefault();

          // If holding and moving, update the direction
          if (this.isHolding && event.touches[0]) {
            const touch = event.touches[0];
            this.currentTouchX = touch.clientX;
            this.currentTouchY = touch.clientY;
          }
        }

        touchEnd(event) {
          event.preventDefault();

          // Clear hold timer and continuous movement
          if (this.holdTimer) {
            clearTimeout(this.holdTimer);
            this.holdTimer = null;
          }

          if (this.continuousTimer) {
            clearInterval(this.continuousTimer);
            this.continuousTimer = null;
          }

          if (!event.changedTouches) return;

          const touch = event.changedTouches[0];
          this.touchEndX = touch.clientX;
          this.touchEndY = touch.clientY;
          const touchDuration = Date.now() - this.touchStartTime;

          console.log(
            "Touch end:",
            this.touchEndX,
            this.touchEndY,
            "Duration:",
            touchDuration
          );

          // If it was a quick tap (not a hold), handle as single movement
          if (!this.isHolding && touchDuration < 200) {
            // Check if it's a swipe or a tap
            const deltaX = this.touchEndX - this.touchStartX;
            const deltaY = this.touchEndY - this.touchStartY;
            const swipeDistance = Math.max(Math.abs(deltaX), Math.abs(deltaY));

            if (swipeDistance >= this.minSwipeDistance) {
              // It's a swipe - handle movement
              this.handleSwipe();
            } else {
              // It's a tap - check for virtual buttons or handle as click
              if (this.current_scene && this.current_scene.name === "inGame") {
                this.handleVirtualButtons(this.touchEndX, this.touchEndY);
              } else {
                // Handle as click for menus and buttons
                this.mouseEvent(event);
              }
            }
          }

          // Reset touch state
          this.isHolding = false;
          this.currentTouchX = null;
          this.currentTouchY = null;
        }

        startContinuousMovement() {
          if (this.continuousTimer) {
            clearInterval(this.continuousTimer);
          }

          // Immediate first move
          this.handleContinuousMove();

          // Set up continuous movement
          this.continuousTimer = setInterval(() => {
            if (this.isHolding) {
              this.handleContinuousMove();
            } else {
              clearInterval(this.continuousTimer);
              this.continuousTimer = null;
            }
          }, this.moveRepeatRate);
        }

        handleContinuousMove() {
          if (
            !this.isHolding ||
            !this.current_scene ||
            this.current_scene.name !== "inGame"
          ) {
            return;
          }

          // Use current touch position if available, otherwise use start position
          const currentX = this.currentTouchX || this.touchStartX;
          const currentY = this.currentTouchY || this.touchStartY;

          const deltaX = currentX - this.touchStartX;
          const deltaY = currentY - this.touchStartY;
          const absDeltaX = Math.abs(deltaX);
          const absDeltaY = Math.abs(deltaY);

          // Determine direction based on touch position or initial swipe
          let moveX = 0,
            moveY = 0;

          if (absDeltaX > absDeltaY && absDeltaX > 30) {
            // Horizontal movement
            moveX = deltaX > 0 ? 1 : -1;
          } else if (absDeltaY > 30) {
            // Vertical movement
            moveY = deltaY > 0 ? 1 : -1;
          } else {
            // If no clear direction from drag, use screen zones
            this.handleVirtualButtons(currentX, currentY);
            return;
          }

          // Execute movement
          if (moveX !== 0 || moveY !== 0) {
            console.log("Continuous move:", moveX, moveY);
            this.current_scene.moveCats(moveX, moveY);
          }
        }

        handleVirtualButtons(x, y) {
          // Get canvas dimensions
          const rect = this.canvas.getBoundingClientRect();
          const canvasWidth = rect.width;
          const canvasHeight = rect.height;

          // Define virtual button areas with improved zones
          const cornerSize = 0.3; // 30% for corner zones (increased from 25%)
          const centerDeadZone = 0.2; // 20% dead zone in center to avoid accidental moves

          // Calculate center bounds
          const centerLeft = canvasWidth * ((1 - centerDeadZone) / 2);
          const centerRight = canvasWidth * ((1 + centerDeadZone) / 2);
          const centerTop = canvasHeight * ((1 - centerDeadZone) / 2);
          const centerBottom = canvasHeight * ((1 + centerDeadZone) / 2);

          // Skip movement if in center dead zone
          if (
            x > centerLeft &&
            x < centerRight &&
            y > centerTop &&
            y < centerBottom
          ) {
            console.log("Touch in center dead zone - no movement");
            return;
          }

          // Determine movement based on which zone is most prominent
          const distanceToLeft = x;
          const distanceToRight = canvasWidth - x;
          const distanceToTop = y;
          const distanceToBottom = canvasHeight - y;

          // Find the minimum distance to determine primary direction
          const minDistance = Math.min(
            distanceToLeft,
            distanceToRight,
            distanceToTop,
            distanceToBottom
          );

          // Only move if we're clearly in a direction zone
          const threshold = canvasWidth * 0.15; // Must be within 15% of edge

          if (minDistance > threshold) {
            console.log("Touch too far from edges - no movement");
            return;
          }

          // Execute movement based on closest edge
          if (minDistance === distanceToTop) {
            console.log("Virtual up button pressed - distance:", minDistance);
            this.current_scene.moveCats(0, -1);
          } else if (minDistance === distanceToBottom) {
            console.log("Virtual down button pressed - distance:", minDistance);
            this.current_scene.moveCats(0, 1);
          } else if (minDistance === distanceToLeft) {
            console.log("Virtual left button pressed - distance:", minDistance);
            this.current_scene.moveCats(-1, 0);
          } else if (minDistance === distanceToRight) {
            console.log(
              "Virtual right button pressed - distance:",
              minDistance
            );
            this.current_scene.moveCats(1, 0);
          }
        }
        handleSwipe() {
          const deltaX = this.touchEndX - this.touchStartX;
          const deltaY = this.touchEndY - this.touchStartY;
          const absDeltaX = Math.abs(deltaX);
          const absDeltaY = Math.abs(deltaY);

          console.log("Swipe detected:", {
            deltaX,
            deltaY,
            absDeltaX,
            absDeltaY,
            minDistance: this.minSwipeDistance,
            scene: this.current_scene?.name,
          });

          // Check if it's a valid swipe (minimum distance)
          if (Math.max(absDeltaX, absDeltaY) < this.minSwipeDistance) {
            console.log("Swipe too small, ignoring");
            return;
          }

          // Only handle swipes during inGame scene
          if (!this.current_scene || this.current_scene.name !== "inGame") {
            console.log("Not in inGame scene, ignoring swipe");
            return;
          }

          // Determine swipe direction and move cats directly
          if (absDeltaX > absDeltaY) {
            // Horizontal swipe
            if (deltaX > 0) {
              // Swipe right
              console.log("Moving right");
              this.current_scene.moveCats(1, 0);
            } else {
              // Swipe left
              console.log("Moving left");
              this.current_scene.moveCats(-1, 0);
            }
          } else {
            // Vertical swipe
            if (deltaY > 0) {
              // Swipe down
              console.log("Moving down");
              this.current_scene.moveCats(0, 1);
            } else {
              // Swipe up
              console.log("Moving up");
              this.current_scene.moveCats(0, -1);
            }
          }
        }

        simulateKeyPress(keyCode) {
          // Create and dispatch the keydown event to the current scene
          const keyDownEvent = new KeyboardEvent("keydown", {
            code: keyCode,
            key: keyCode.replace("Arrow", "Arrow"),
            bubbles: true,
            cancelable: true,
          });

          // Call the scene's keyEvents function
          if (this.current_scene && this.current_scene.keyEvents) {
            this.current_scene.keyEvents(keyDownEvent);
          }
        }

        mouseEvent(event) {
          // Call mouseEvents method of current scene if it exists
          if (
            this.current_scene &&
            typeof this.current_scene.mouseEvents === "function"
          ) {
            this.current_scene.mouseEvents(event);
          }
        }
        // ---
        // Scene Manager
        // ---
        startScene(scene_name) {
          // check if the scene exist
          if (this.scenes[scene_name] === undefined)
            return scene_name + " - doesn't exist";
          // request the change of scene if this.main_loop is active
          if (this.main_loop !== undefined) {
            this.requestChange.value = true;
            this.requestChange.action = scene_name;
            return false;
          }
          this.requestChange.value = false;
          this.requestChange.action = "";
          this.FPS.last = Util.timeStamp();
          this.current_scene = this.scenes[scene_name];
          this.initScene();
          // does this scenes needs a gameloop ?
          if (this.current_scene.loop === true) {
            this.gameLoop();
          } else {
            this.mainRender();
          }
        }
        initScene() {
          if (this.current_scene.init_once) return false;
          this.current_scene.init();
        }
        addScene(scene) {
          // links this world to this scene
          scene.giveWorld(this);
          this.scenes[scene.name] = scene;
        }
        // ---
        // Main Loop
        // ---
        mainRender() {
          this.clear();
          this.current_scene.render();
        }
        loopCheck() {
          if (this.requestChange.value === false) {
            this.main_loop = requestAnimationFrame(() => this.gameLoop());
          } else {
            cancelAnimationFrame(this.main_loop);
            this.main_loop = undefined;
            this.startScene(this.requestChange.action);
          }
        }
        gameLoop() {
          this.FPS.now = Util.timeStamp();
          this.FPS.delta += Math.min(1, (this.FPS.now - this.FPS.last) / 1000);
          while (this.FPS.delta > this.FPS.step) {
            this.FPS.delta -= this.FPS.step;
            this.mainRender();
          }
          this.FPS.last = this.FPS.now;
          this.loopCheck();
        }
        // Basic functions
        soundLevel(volume) {
          for (let [k, v] of Object.entries(this.assets.audio)) {
            v.audio.volume = volume;
          }
        }
        mute() {
          this.audio_muted = !this.audio_muted;
          for (let [k, v] of Object.entries(this.assets.audio)) {
            v.audio.muted = this.audio_muted;
          }
        }
        clear(custom_color) {
          this.ctx.fillStyle = custom_color || this.background_color;
          this.ctx.fillRect(0, 0, this.W, this.H);
        }
        setScale() {
          this.canvas.style.width = this.W * this.scale + "px";
          this.canvas.style.height = this.H * this.scale + "px";
        }
        fullScreen() {
          this.full = !this.full;
          if (!this.full) {
            this.setScale();
          } else {
            this.canvas.style.width = "100%";
            this.canvas.style.height = "100%";
          }
        }
        // ---
        // Tile map
        // ---
        getTile(layer_id, x, y) {
          if (x < 0 || x > this.terrain.layers[layer_id].size.x - 1)
            return false;
          if (y < 0 || y > this.terrain.layers[layer_id].size.y - 1)
            return false;
          let tile =
            this.tiles_data[this.terrain.layers[layer_id].geometry[y][x]];
          if (tile === undefined) return false;
          return tile;
        }
        setTile(layer_id, x, y, tile_id) {
          if (x < 0 || x > this.terrain.layers[layer_id].size.x - 1)
            return false;
          if (y < 0 || y > this.terrain.layers[layer_id].size.y - 1)
            return false;
          this.terrain.layers[layer_id].geometry[y][x] = tile_id;
          return true;
        }
        findTile(layer_id, tile_id) {
          let layer = this.terrain.layers[layer_id];
          let result = [];
          for (let y = 0; y < layer.size.y; y++) {
            for (let x = 0; x < layer.size.x; x++) {
              let id = layer.geometry[y][x];
              if (id === tile_id) {
                result.push({ x: x, y: y });
              }
            }
          }
          return result;
        }
        initMap(map_name) {
          this.terrain = JSON.parse(JSON.stringify(this.maps[map_name]));
          // give size to layers
          for (var i = 0; i < this.terrain.layers.length; i++) {
            this.terrain.layers[i].size = {
              x: this.terrain.layers[i].geometry[0].length,
              y: this.terrain.layers[i].geometry.length,
            };
          }
          this.terrain.tileset =
            this.assets.image[this.maps[map_name].tileset].image;
          this.terrain.tileset_size = {
            width: this.terrain.tileset.width / this.tile_size,
            height: this.terrain.tileset.height / this.tile_size + 1,
          };
          this.terrain.layers.forEach((layer, index) => {
            this.marchingSquare(layer);
            this.bitMasking(layer);

            // create a cache for reducing draw call in the gameLoop
            this.terrainCache(layer);
            // prepare animated tiles
            layer.animated = [];
            for (var id in this.tiles_data) {
              if (this.tiles_data[id].animated === true) {
                let tiles = this.findTile(index, parseInt(id));
                layer.animated.push({
                  id: id,
                  spritesheet:
                    this.assets.image[this.tiles_data[id].spritesheet].image,
                  positions: tiles,
                  current: 0,
                  steps: this.tiles_data[id].steps,
                  max_frame:
                    this.assets.image[this.tiles_data[id].spritesheet].image
                      .width / this.tile_size,
                });
              }
            }
          });
          this.clear("black");
        }
        terrainCache(layer) {
          layer.cache = {};
          let c = (layer.cache.c = document.createElement("canvas"));
          let ctx = (layer.cache.ctx = layer.cache.c.getContext("2d"));
          let W = (c.width = layer.size.x * this.tile_size),
            H = (c.height = layer.size.y * this.tile_size);
          // Draw on cache
          this.ctx.clearRect(0, 0, W, H);
          this.drawLayer(layer);
          ctx.drawImage(this.canvas, 0, 0);
          this.clear();
        }
        marchingSquare(layer) {
          layer.square = [];
          for (let y = 0; y < layer.size.y; y++) {
            for (let x = 0; x < layer.size.x; x++) {
              let p1 = 0,
                p2 = 0,
                p3 = 0,
                p4 = 0;

              if (y + 1 < layer.size.y && x + 1 < layer.size.x) {
                p1 = layer.geometry[y][x];
                p2 = layer.geometry[y][x + 1];
                p3 = layer.geometry[y + 1][x + 1];
                p4 = layer.geometry[y + 1][x];
              }
              let id = p1 * 8 + p2 * 4 + p3 * 2 + p4;
              layer.square.push(id);
            }
          }

          layer.square = Util.array2D(layer.square, layer.size.x);
        }
        bitMasking(layer) {
          layer.bitMask = [];
          for (let y = 0; y < layer.size.y; y++) {
            for (let x = 0; x < layer.size.x; x++) {
              let id = layer.geometry[y][x];
              let neighbor = [0, 0, 0, 0];
              if (y - 1 > -1) {
                if (id === layer.geometry[y - 1][x]) {
                  //top
                  neighbor[0] = 1;
                }
              } else {
                neighbor[0] = 1;
              }
              if (x - 1 > -1) {
                if (id === layer.geometry[y][x - 1]) {
                  // left
                  neighbor[1] = 1;
                }
              } else {
                neighbor[1] = 1;
              }
              if (x + 1 < layer.size.x) {
                if (id === layer.geometry[y][x + 1]) {
                  // right
                  neighbor[2] = 1;
                }
              } else {
                neighbor[2] = 1;
              }

              if (y + 1 < layer.size.y) {
                if (id === layer.geometry[y + 1][x]) {
                  //down
                  neighbor[3] = 1;
                }
              } else {
                neighbor[3] = 1;
              }
              id =
                1 * neighbor[0] +
                2 * neighbor[1] +
                4 * neighbor[2] +
                8 * neighbor[3];
              layer.bitMask.push(id);
            }
          }
          layer.bitMask = Util.array2D(layer.bitMask, layer.size.x);
        }
        renderMap() {
          this.terrain.layers.forEach((layer) => {
            this.ctx.drawImage(layer.cache.c, 0, 0);
            // draw animated layer
            layer.animated.forEach((tile) => {
              if (tile.current < tile.max_frame - 1) {
                tile.current += tile.steps;
              } else {
                tile.current = 0;
              }
              // render animated tiles
              tile.positions.forEach((position) => {
                let x = position.x * this.tile_size,
                  y = position.y * this.tile_size;

                // Add black border effect for exit tile
                if (tile.id == "8") {
                  // exit tile id
                  // Save context for effects
                  this.ctx.save();

                  // Force smooth rendering for this specific image
                  this.ctx.mozImageSmoothingEnabled = true;
                  this.ctx.webkitImageSmoothingEnabled = true;
                  this.ctx.msImageSmoothingEnabled = true;
                  this.ctx.imageSmoothingEnabled = true;
                  this.ctx.imageSmoothingQuality = "high";

                  // Calculate center and radius for circular border
                  let centerX = x + this.tile_size / 2;
                  let centerY = y + this.tile_size / 2;
                  let radius = this.tile_size / 2 - 1; // Slightly smaller to fit within tile

                  // Draw thick black border for circular logo
                  this.ctx.beginPath();
                  this.ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
                  this.ctx.strokeStyle = "black";
                  this.ctx.lineWidth = 4;
                  this.ctx.stroke();

                  // Draw the logo
                  this.ctx.drawImage(
                    tile.spritesheet,
                    x,
                    y,
                    this.tile_size,
                    this.tile_size
                  );

                  this.ctx.restore();
                } else if (tile.id == "17") {
                  // coin tile id - special handling for 32x32 frames
                  this.ctx.save();

                  // Force smooth rendering for coin
                  this.ctx.mozImageSmoothingEnabled = true;
                  this.ctx.webkitImageSmoothingEnabled = true;
                  this.ctx.msImageSmoothingEnabled = true;
                  this.ctx.imageSmoothingEnabled = true;
                  this.ctx.imageSmoothingQuality = "high";

                  // Ensure frame index is always valid (0-7)
                  let frameIndex = Math.floor(tile.current) % 8;
                  if (frameIndex < 0) frameIndex = 0;
                  if (frameIndex > 7) frameIndex = 7;

                  // Draw the coin with correct frame size (32x32 frames)
                  this.ctx.drawImage(
                    tile.spritesheet,
                    frameIndex * 32, // 32px per frame
                    0,
                    32, // source width
                    32, // source height
                    x,
                    y,
                    this.tile_size, // scale to game tile size (16x16)
                    this.tile_size
                  );

                  this.ctx.restore();
                } else {
                  // Normal animated tile rendering
                  this.ctx.drawImage(
                    tile.spritesheet,
                    Math.floor(tile.current) * this.tile_size,
                    0,
                    this.tile_size,
                    this.tile_size,
                    x,
                    y,
                    this.tile_size,
                    this.tile_size
                  );
                }
              });
            });
          });
        }
        drawMap() {
          this.terrain.layers.forEach((layer) => {
            this.drawLayer(layer);
          });
        }
        drawLayer(layer) {
          for (let y = 0; y < layer.size.y; y++) {
            for (let x = 0; x < layer.size.x; x++) {
              // ID of the tile
              let id = layer.geometry[y][x];
              // Don't draw invisible tiles
              // Position of the tile :)
              let positionX = x * this.tile_size + layer.offset.x,
                positionY = y * this.tile_size + layer.offset.y;
              let sourceX =
                  Math.floor(id % this.terrain.tileset_size.width) *
                  this.tile_size,
                sourceY =
                  Math.floor(id / this.terrain.tileset_size.width) *
                  this.tile_size;
              if (
                this.tiles_data[id] &&
                this.tiles_data[id].look === "bitmask"
              ) {
                sourceX = Math.floor(layer.bitMask[y][x]) * this.tile_size;
                sourceY = this.tiles_data[id].line * this.tile_size;
              }

              if (layer.look === "square") {
                if (layer.square[y][x] === 0) continue;
                positionX += this.tile_size / 2;
                positionY += this.tile_size / 2;
                sourceX = Math.floor(layer.square[y][x] % 16) * 16;
                sourceY = 7 * this.tile_size;
              }

              if (
                this.tiles_data[id] &&
                this.tiles_data[id].animated === true
              ) {
                // hide animated sprites on the cache
                continue;
              }

              // render tile

              this.ctx.drawImage(
                this.terrain.tileset,
                sourceX,
                sourceY,
                this.tile_size,
                this.tile_size,
                positionX,
                positionY,
                this.tile_size,
                this.tile_size
              );
            }
          }
        }
      }
      let parameters = {
        name: "Copycat",
        start_screen: "menu",
        background_color: "#223d8c",
        width: 256,
        height: 256,
        tile_size: 16,
        assets: [
          // Images
          {
            type: "img",
            name: "pirate_captain_idle",
            path: "https://i.postimg.cc/nMbRcHGM/Pirate-Captain-Idle.png",
          },
          {
            type: "img",
            name: "pirate_captain_walk",
            path: "https://i.postimg.cc/KvtF7jVq/Pirate-Captain-Walk.png",
          },
          {
            type: "img",
            name: "spawn_effect",
            path: "https://image.ibb.co/njVQnT/spawn_effect.png",
          },
          {
            type: "img",
            name: "water_splash",
            path: "https://image.ibb.co/jm7hZ8/water_splash.png",
          },
          {
            type: "img",
            name: "shadow",
            path: "https://image.ibb.co/djchZ8/shadow.png",
          },
          {
            type: "img",
            name: "main_title",
            path: "https://i.postimg.cc/Gm1h8VLy/opensea-logo.png",
          },
          {
            type: "img",
            name: "box_texture",
            path: "https://image.ibb.co/kpO0Mo/box.png",
          },
          {
            type: "img",
            name: "selection",
            path: "https://image.ibb.co/fmJpE8/selection.png",
          },
          {
            type: "img",
            name: "flat_frame",
            path: "https://image.ibb.co/hqSugo/flat_frame.png",
          },
          {
            type: "img",
            name: "pattern",
            path: "https://i.postimg.cc/wMk6nk4Z/water.png",
          },
          {
            type: "img",
            name: "menu_background",
            path: "https://i.postimg.cc/nccy2ZZn/pngwing-com-12.png",
          },
          {
            type: "img",
            name: "demo_tileset",
            path: "https://image.ibb.co/b8rLMo/demo_tileset.png",
          },
          {
            type: "img",
            name: "exit",
            path: "https://i.postimg.cc/Hsjjcqrh/opensea.png",
          },
          {
            type: "img",
            name: "water_sprite",
            path: "https://image.ibb.co/cSFEgo/water_sprite.png",
          },
          {
            type: "img",
            name: "dust_effect",
            path: "https://image.ibb.co/mKy0Mo/dust.png",
          },
          {
            type: "img",
            name: "coin_sprite",
            path: "https://i.postimg.cc/jdKmMf0V/coin.png",
          },
          {
            type: "img",
            name: "surrender_button",
            path: "https://i.postimg.cc/KYTPr4CY/redbutton.png",
          },
          // Audio
          {
            type: "audio",
            name: "jingle",
            path: "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/6d6bc837-fad6-47ee-91cd-cdfeb472750a/waves-bWs1OMPYRpODjTOSXkwhP9CNBPVEMm.mp3?01R0",
          },
          {
            type: "audio",
            name: "selection",
            path: "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/6d6bc837-fad6-47ee-91cd-cdfeb472750a/exit-Wo1n7ZwfI9XI86Ts2dqx3QfcpWwaw1.mp3?nz0F",
          },
          {
            type: "audio",
            name: "coin_collect",
            path: "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/6d6bc837-fad6-47ee-91cd-cdfeb472750a/collectcoin-6075-rjrkxbNHSsH3QzqnurDamQrx3K87pQ.mp3?vsYo",
          },
          {
            type: "audio",
            name: "eboulement",
            path: "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/6d6bc837-fad6-47ee-91cd-cdfeb472750a/game-over-eXhbU57XcekmZPntLzuPIn06iXDjbN.mp3?jVoy",
          },
          {
            type: "audio",
            name: "splash",
            path: "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/6d6bc837-fad6-47ee-91cd-cdfeb472750a/splash-SOkXu7Zfm7m9DomHSWtNm6we2H9Rwq.mp3?7gjD",
          },
          {
            type: "audio",
            name: "pirate1",
            path: "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/6d6bc837-fad6-47ee-91cd-cdfeb472750a/pirate1-6BrzaKv8igJ1h5IJa3phuLnB0fCX6V.mp3?LPuj",
          },
          {
            type: "audio",
            name: "pirate2",
            path: "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/6d6bc837-fad6-47ee-91cd-cdfeb472750a/pirate2-8lCFdORuSCzXZCZuW1XFcFFX8ONXPK.mp3?BE5D",
          },
          {
            type: "audio",
            name: "pirate3",
            path: "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/6d6bc837-fad6-47ee-91cd-cdfeb472750a/pirate3-aDQYxQ22RFTy38OUPgzf6Q7Tib4WHY.mp3?V3je",
          },

          // No bitmap fonts needed - using Google Fonts instead
        ],
        fonts: [
          // All fonts now use Google Fonts (Pirata One, etc.)
        ],
        // box system
        boxes: [
          {
            name: "box",
            resolution: 8,
            image: "box_texture",
          },
          {
            name: "selection",
            resolution: 8,
            image: "selection",
          },
          {
            name: "flat_frame",
            resolution: 8,
            image: "flat_frame",
          },
        ],
        tiles: [
          { name: "empty", id: 0, collision: false, visibility: false },
          { name: "water", id: 1, collision: false, look: "square", line: 7 },
          { name: "shores", id: 2, collision: false, look: "bitmask", line: 6 },
          { name: "ground", id: 3, collision: false, look: "bitmask", line: 1 },
          { name: "wall", id: 4, collision: true, look: "bitmask", line: 2 },
          { name: "fence", id: 11, collision: true, look: "bitmask", line: 4 },
          { name: "bush", id: 5, collision: true },
          { name: "ice", id: 6, collision: false, look: "bitmask", line: 3 },
          { name: "spawn", id: 7, collision: false },
          {
            name: "exit",
            id: 8,
            collision: false,
            animated: true,
            spritesheet: "exit",
            steps: 0.4,
          },
          {
            name: "waves",
            id: 16,
            collision: false,
            animated: true,
            spritesheet: "water_sprite",
            steps: 0.2,
          },
          { name: "trap", id: 9, collision: false },
          { name: "hole", id: 10, collision: true },
          // arrows
          { name: "arrowLeft", id: 12, collision: false },
          { name: "arrowUp", id: 13, collision: false },
          { name: "arrowRight", id: 14, collision: false },
          { name: "arrowDown", id: 15, collision: false },
          {
            name: "coin",
            id: 17,
            collision: false,
            animated: true,
            spritesheet: "coin_sprite",
            steps: 0.08,
          },
        ],
        maps: [
          // map 1
          {
            name: "map_1",
            tileset: "demo_tileset",
            // ground
            layers: [
              // ground layer
              {
                name: "ground",
                offset: {
                  x: 0,
                  y: 4,
                },
                geometry: [
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 3, 3, 0, 0, 0, 3, 3, 3, 3, 3, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0],
                  [0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                ],
              },
              // ice / arrows / layer
              {
                name: "onGround",
                offset: {
                  x: 0,
                  y: 0,
                },
                geometry: [
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 11, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 11, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 8, 5, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 5, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                ],
              },
              // wall layer
              {
                name: "wall",
                offset: {
                  x: 0,
                  y: 0,
                },
                geometry: [
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                ],
              },
            ],
          },
          // map 2
          {
            name: "map_2",
            tileset: "demo_tileset",
            // ground
            layers: [
              // ground layer
              {
                name: "ground",
                offset: {
                  x: 0,
                  y: 4,
                },
                geometry: [
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 3, 3, 3, 3, 3, 0, 0, 3, 3, 3, 3, 3, 0, 0],
                  [0, 0, 3, 3, 3, 3, 3, 0, 0, 3, 3, 3, 3, 3, 0, 0],
                  [0, 0, 3, 3, 3, 3, 3, 0, 0, 3, 3, 3, 3, 3, 0, 0],
                  [0, 0, 3, 3, 3, 3, 3, 0, 0, 3, 3, 3, 3, 3, 0, 0],
                  [0, 0, 3, 3, 3, 3, 3, 0, 0, 3, 3, 3, 3, 3, 0, 0],
                  [0, 0, 3, 3, 3, 3, 3, 0, 0, 3, 3, 3, 3, 3, 0, 0],
                  [0, 0, 3, 3, 3, 3, 3, 0, 0, 3, 3, 3, 3, 3, 0, 0],
                  [0, 0, 3, 3, 3, 3, 3, 0, 0, 3, 3, 3, 3, 3, 0, 0],
                  [0, 0, 3, 3, 3, 3, 3, 0, 0, 3, 3, 3, 3, 3, 0, 0],
                  [0, 0, 3, 3, 3, 3, 3, 0, 0, 3, 3, 3, 3, 3, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                ],
              },
              // ice / arrows / layer
              {
                name: "onGround",
                offset: {
                  x: 0,
                  y: 0,
                },
                geometry: [
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 11, 11, 11, 11, 11, 0, 0, 11, 11, 11, 11, 11, 0, 0],
                  [0, 0, 11, 0, 0, 0, 11, 0, 0, 11, 0, 0, 17, 11, 0, 0],
                  [0, 0, 11, 0, 8, 0, 11, 0, 0, 11, 0, 8, 0, 11, 0, 0],
                  [0, 0, 11, 0, 0, 0, 11, 0, 0, 11, 0, 0, 0, 11, 0, 0],
                  [0, 0, 11, 17, 0, 0, 11, 0, 0, 11, 0, 0, 0, 11, 0, 0],
                  [0, 0, 11, 4, 4, 0, 11, 0, 0, 11, 0, 0, 0, 11, 0, 0],
                  [0, 0, 11, 0, 0, 0, 11, 0, 0, 11, 0, 4, 4, 11, 0, 0],
                  [0, 0, 11, 0, 0, 0, 11, 0, 0, 11, 0, 0, 0, 11, 0, 0],
                  [0, 0, 11, 0, 7, 0, 11, 0, 0, 11, 0, 7, 0, 11, 0, 0],
                  [0, 0, 11, 11, 11, 11, 11, 0, 0, 11, 11, 11, 11, 11, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                ],
              },
              // wall layer
            ],
          },
          {
            name: "map_3",
            tileset: "demo_tileset",
            // ground
            layers: [
              // ground layer
              {
                name: "ground",
                offset: {
                  x: 0,
                  y: 4,
                },
                geometry: [
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 0, 0, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 0, 0, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 0, 0, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 0, 0, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 0, 0, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 0, 0, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 0, 0, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 0, 0, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 0, 0, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 0, 0, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                ],
              },
              // ice / arrows / layer
              {
                name: "onGround",
                offset: {
                  x: 0,
                  y: 0,
                },
                geometry: [
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0],
                  [0, 0, 4, 0, 0, 0, 17, 0, 0, 17, 0, 0, 0, 4, 0, 0],
                  [0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0],
                  [0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 4, 0, 0],
                  [0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0],
                  [0, 0, 4, 8, 0, 0, 0, 0, 0, 0, 5, 0, 0, 4, 0, 0],
                  [0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0],
                  [0, 0, 4, 11, 11, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0],
                  [0, 0, 4, 7, 0, 0, 0, 0, 0, 0, 0, 7, 0, 4, 0, 0],
                  [0, 0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                ],
              },
              // wall layer
            ],
          },

          {
            name: "map_4",
            tileset: "demo_tileset",
            // ground
            layers: [
              // ground layer
              {
                name: "ground",
                offset: {
                  x: 0,
                  y: 4,
                },
                geometry: [
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0],
                  [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0],
                  [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0],
                  [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0],
                  [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0],
                  [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0],
                  [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0],
                  [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0],
                  [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0],
                  [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0],
                  [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0],
                  [0, 0, 0, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                ],
              },
              // ice / arrows / layer
              {
                name: "onGround",
                offset: {
                  x: 0,
                  y: 0,
                },
                geometry: [
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 11, 11, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 17, 11, 0, 0, 0],
                  [0, 0, 0, 0, 11, 11, 11, 0, 0, 0, 11, 0, 11, 0, 0, 0],
                  [0, 0, 0, 0, 11, 0, 11, 0, 0, 0, 11, 0, 11, 0, 0, 0],
                  [0, 0, 0, 0, 11, 0, 11, 0, 0, 0, 11, 9, 11, 0, 0, 0],
                  [0, 0, 0, 0, 11, 8, 11, 0, 0, 0, 11, 8, 11, 0, 0, 0],
                  [0, 0, 0, 0, 11, 0, 11, 0, 0, 0, 11, 7, 11, 0, 0, 0],
                  [0, 0, 0, 0, 11, 0, 11, 0, 0, 0, 11, 0, 11, 0, 0, 0],
                  [0, 0, 0, 0, 11, 0, 11, 5, 0, 0, 11, 11, 11, 0, 0, 0],
                  [0, 0, 0, 0, 11, 7, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 11, 11, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                ],
              }, // wall layer
            ],
          },
          {
            name: "map_5",
            tileset: "demo_tileset",
            // ground
            layers: [
              // ground layer
              {
                name: "ground",
                offset: {
                  x: 0,
                  y: 4,
                },
                geometry: [
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                ],
              },
              // ice / arrows / layer
              {
                name: "onGround",
                offset: {
                  x: 0,
                  y: 0,
                },
                geometry: [
                  [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
                  [4, 0, 5, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
                  [4, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
                  [4, 4, 4, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 4, 4, 4],
                  [4, 4, 4, 6, 6, 6, 6, 6, 6, 6, 17, 6, 6, 4, 4, 4],
                  [4, 4, 4, 6, 5, 6, 6, 6, 6, 6, 6, 6, 6, 4, 4, 4],
                  [4, 4, 4, 6, 6, 6, 6, 6, 6, 6, 6, 5, 6, 4, 4, 4],
                  [4, 4, 4, 6, 6, 6, 6, 6, 4, 6, 6, 6, 6, 8, 4, 4],
                  [4, 4, 4, 6, 6, 4, 6, 6, 4, 6, 4, 4, 6, 4, 4, 4],
                  [4, 4, 4, 4, 6, 6, 6, 6, 4, 6, 6, 6, 6, 4, 4, 4],
                  [4, 4, 4, 6, 6, 6, 6, 6, 6, 17, 6, 6, 6, 4, 4, 4],
                  [4, 4, 4, 6, 6, 6, 5, 6, 6, 6, 6, 0, 0, 4, 4, 4],
                  [4, 4, 4, 6, 6, 6, 6, 6, 6, 6, 6, 0, 7, 4, 4, 4],
                  [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 4],
                  [4, 5, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 4],
                  [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
                ],
              }, // wall layer
            ],
          },

          {
            name: "map_6",
            tileset: "demo_tileset",
            // ground
            layers: [
              // ground layer
              {
                name: "ground",
                offset: {
                  x: 0,
                  y: 4,
                },
                geometry: [
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                ],
              },
              // ice / arrows / layer
              {
                name: "onGround",
                offset: {
                  x: 0,
                  y: 0,
                },
                geometry: [
                  [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
                  [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
                  [4, 4, 4, 6, 6, 14, 0, 6, 6, 6, 6, 15, 4, 4, 4, 4],
                  [4, 4, 4, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 4, 4, 4],
                  [4, 4, 4, 6, 6, 6, 8, 6, 6, 6, 4, 6, 17, 4, 4, 4],
                  [4, 4, 4, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 4, 4, 4],
                  [4, 4, 4, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 4, 4, 4],
                  [4, 4, 4, 6, 6, 6, 6, 6, 6, 6, 6, 7, 6, 4, 4, 4],
                  [4, 4, 4, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 4, 4, 4],
                  [4, 4, 4, 6, 6, 14, 6, 6, 6, 6, 6, 6, 4, 4, 4, 4],
                  [4, 4, 4, 6, 6, 6, 6, 6, 6, 6, 0, 6, 4, 4, 4, 4],
                  [4, 4, 4, 6, 6, 0, 6, 6, 6, 6, 6, 6, 6, 4, 4, 4],
                  [4, 4, 4, 6, 6, 6, 6, 6, 6, 17, 6, 8, 13, 4, 4, 4],
                  [4, 4, 4, 6, 6, 6, 7, 6, 6, 6, 6, 6, 6, 4, 4, 4],
                  [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
                  [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
                ],
              }, // wall layer
            ],
          },

          {
            name: "map_7",
            tileset: "demo_tileset",
            // ground
            layers: [
              // ground layer
              {
                name: "ground",
                offset: {
                  x: 0,
                  y: 4,
                },
                geometry: [
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                ],
              },
              // ice / arrows / layer - MAZE LAYOUT
              {
                name: "onGround",
                offset: {
                  x: 0,
                  y: 0,
                },
                geometry: [
                  [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
                  [4, 0, 6, 4, 6, 6, 4, 6, 6, 6, 4, 6, 6, 6, 8, 4],
                  [4, 6, 6, 4, 6, 4, 4, 6, 4, 6, 4, 6, 4, 4, 6, 4],
                  [4, 6, 4, 4, 6, 4, 6, 6, 4, 6, 6, 6, 4, 17, 6, 4],
                  [4, 6, 6, 6, 6, 4, 6, 4, 4, 4, 4, 6, 4, 6, 4, 4],
                  [4, 4, 4, 6, 4, 4, 6, 6, 6, 6, 4, 6, 6, 6, 4, 4],
                  [4, 6, 6, 6, 4, 6, 6, 4, 6, 4, 4, 4, 6, 4, 4, 4],
                  [4, 6, 4, 4, 4, 6, 4, 4, 6, 6, 6, 6, 6, 6, 5, 4],
                  [4, 6, 6, 6, 6, 6, 4, 6, 6, 4, 6, 4, 4, 4, 6, 4],
                  [4, 4, 6, 4, 4, 4, 4, 6, 4, 4, 6, 6, 6, 6, 6, 4],
                  [4, 5, 6, 6, 6, 6, 6, 6, 4, 17, 6, 4, 6, 4, 6, 4],
                  [4, 6, 4, 6, 4, 4, 4, 6, 4, 6, 6, 4, 6, 6, 6, 4],
                  [4, 6, 4, 6, 6, 6, 6, 6, 6, 6, 4, 4, 4, 6, 4, 4],
                  [4, 6, 4, 4, 4, 6, 4, 4, 4, 6, 6, 6, 5, 6, 7, 4],
                  [4, 6, 6, 6, 6, 6, 6, 6, 6, 6, 4, 4, 6, 4, 4, 4],
                  [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
                ],
              }, // wall layer
            ],
          },

          {
            name: "map_8",
            tileset: "demo_tileset",
            // ground - Advanced Two Pirates Challenge
            layers: [
              // ground layer
              {
                name: "ground",
                offset: {
                  x: 0,
                  y: 4,
                },
                geometry: [
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 0],
                  [0, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 0],
                  [0, 3, 3, 3, 3, 0, 0, 3, 3, 0, 0, 3, 3, 3, 3, 0],
                  [0, 3, 3, 3, 3, 0, 0, 3, 3, 0, 0, 3, 3, 3, 3, 0],
                  [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0],
                  [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0],
                  [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0],
                  [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0],
                  [0, 3, 3, 3, 3, 0, 0, 3, 3, 0, 0, 3, 3, 3, 3, 0],
                  [0, 3, 3, 3, 3, 0, 0, 3, 3, 0, 0, 3, 3, 3, 3, 0],
                  [0, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 0],
                  [0, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                ],
              },
              // Complex multi-island layout with bridges and obstacles
              {
                name: "onGround",
                offset: {
                  x: 0,
                  y: 0,
                },
                geometry: [
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 11, 11, 11, 11, 0, 0, 0, 0, 0, 0, 11, 11, 11, 11, 0],
                  [0, 11, 0, 5, 11, 0, 0, 0, 0, 0, 0, 0, 17, 0, 11, 0],
                  [0, 11, 0, 7, 11, 0, 0, 11, 11, 0, 0, 0, 5, 0, 11, 0],
                  [0, 11, 17, 0, 11, 0, 0, 11, 11, 0, 0, 0, 0, 8, 11, 0],
                  [0, 0, 0, 0, 11, 11, 11, 11, 11, 11, 11, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0],
                  [0, 11, 11, 0, 11, 0, 0, 11, 11, 0, 0, 11, 0, 11, 11, 0],
                  [0, 11, 8, 0, 11, 0, 0, 11, 11, 0, 0, 11, 0, 7, 11, 0],
                  [0, 11, 5, 0, 11, 0, 0, 0, 0, 0, 0, 11, 0, 17, 11, 0],
                  [0, 11, 11, 11, 11, 0, 0, 0, 0, 0, 0, 11, 11, 11, 11, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                ],
              }, // wall layer
            ],
          },

          {
            name: "map_9",
            tileset: "demo_tileset",
            // Water Maze Challenge - Single Pirate
            layers: [
              // ground layer - crear un laberinto con caminos de tierra rodeados de agua
              {
                name: "ground",
                offset: {
                  x: 0,
                  y: 4,
                },
                geometry: [
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 3, 0, 3, 3, 0, 0, 3, 3, 3, 3, 0, 0, 3, 0, 0],
                  [0, 3, 0, 0, 3, 0, 0, 3, 0, 0, 3, 0, 0, 3, 0, 0],
                  [0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 3, 3, 3, 3, 3, 0],
                  [0, 0, 3, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 3, 0],
                  [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 3, 0],
                  [0, 0, 3, 0, 0, 3, 3, 3, 3, 0, 0, 3, 0, 0, 3, 0],
                  [0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 3, 3, 3, 3, 0],
                  [0, 3, 0, 0, 3, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0],
                  [0, 3, 0, 3, 3, 3, 3, 3, 0, 3, 3, 3, 3, 3, 0, 0],
                  [0, 3, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0],
                  [0, 3, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0],
                  [0, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                ],
              },
              // coins y spawn/exit - distribuir monedas estratgicamente por el laberinto
              {
                name: "onGround",
                offset: {
                  x: 0,
                  y: 0,
                },
                geometry: [
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 7, 0, 0, 0, 0, 0, 17, 0, 0, 0, 0, 0, 17, 0, 0],
                  [0, 0, 0, 0, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 17, 0, 0, 0, 0, 0, 17, 0, 0, 0, 0],
                  [0, 0, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 17, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 17, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 17, 0, 0, 0, 0, 0, 0, 0, 17, 0, 0, 0],
                  [0, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 8, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                ],
              }, // coins layer
            ],
          },

          {
            name: "map_10",
            tileset: "demo_tileset",
            // Horizontal Twin Pirate Challenge - Ice & Earth Adventure
            layers: [
              // ground layer - todo terreno slido, sin agua (basado en map_6)
              {
                name: "ground",
                offset: {
                  x: 0,
                  y: 4,
                },
                geometry: [
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                ],
              },
              // rutas horizontales separadas con obstculos (NIVEL EXTREMO)
              {
                name: "onGround",
                offset: {
                  x: 0,
                  y: 0,
                },
                geometry: [
                  [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
                  [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
                  [4, 7, 6, 6, 5, 6, 6, 6, 11, 6, 6, 5, 6, 6, 6, 4],
                  [4, 6, 6, 6, 17, 6, 5, 6, 6, 6, 11, 6, 6, 5, 6, 4],
                  [4, 5, 6, 6, 6, 11, 6, 6, 6, 6, 6, 6, 11, 6, 6, 4],
                  [4, 6, 6, 5, 6, 6, 6, 11, 6, 6, 5, 6, 6, 8, 6, 4],
                  [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
                  [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
                  [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
                  [4, 6, 6, 11, 6, 6, 5, 6, 6, 6, 11, 6, 6, 5, 6, 4],
                  [4, 17, 6, 6, 6, 11, 6, 6, 5, 6, 6, 6, 11, 6, 6, 4],
                  [4, 8, 5, 6, 6, 6, 6, 17, 6, 5, 6, 6, 6, 6, 7, 4],
                  [4, 6, 6, 6, 11, 6, 6, 5, 6, 6, 6, 11, 6, 6, 5, 4],
                  [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
                  [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
                  [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
                ],
              }, // obstacles layer
            ],
          },

          {
            name: "map_11",
            tileset: "demo_tileset",
            // Ice Sliding Puzzle - Inspirado en Chip's Challenge + Lolo
            layers: [
              // ground layer - todo terreno slido
              {
                name: "ground",
                offset: {
                  x: 0,
                  y: 4,
                },
                geometry: [
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                ],
              },
              // Ice sliding puzzle con arbustos como frenos
              {
                name: "onGround",
                offset: {
                  x: 0,
                  y: 0,
                },
                geometry: [
                  [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
                  [4, 7, 6, 6, 6, 5, 6, 6, 6, 6, 5, 6, 6, 17, 8, 4],
                  [4, 4, 4, 4, 6, 4, 4, 4, 4, 6, 4, 4, 4, 4, 4, 4],
                  [4, 17, 6, 6, 6, 6, 6, 5, 6, 6, 6, 6, 6, 17, 6, 4],
                  [4, 4, 4, 5, 6, 4, 4, 4, 4, 6, 5, 4, 4, 4, 4, 4],
                  [4, 6, 6, 6, 6, 6, 17, 6, 6, 6, 6, 6, 6, 6, 17, 4],
                  [4, 6, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 6, 4],
                  [4, 5, 6, 6, 6, 6, 6, 5, 6, 6, 6, 6, 6, 6, 5, 4],
                  [4, 6, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 6, 4],
                  [4, 17, 6, 6, 6, 6, 6, 17, 6, 6, 6, 6, 6, 6, 6, 4],
                  [4, 4, 4, 5, 6, 4, 4, 4, 4, 6, 5, 4, 4, 4, 4, 4],
                  [4, 6, 6, 6, 6, 6, 6, 5, 6, 6, 6, 6, 6, 17, 6, 4],
                  [4, 4, 4, 4, 6, 4, 4, 4, 4, 6, 4, 4, 4, 4, 4, 4],
                  [4, 17, 6, 6, 6, 5, 6, 6, 6, 6, 5, 6, 6, 17, 6, 4],
                  [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
                  [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
                ],
              }, // ice sliding layer
            ],
          },

          {
            name: "map_12",
            tileset: "demo_tileset",
            // Water Maze Advanced - Inspirado en Sokoban + decisiones sin retorno
            layers: [
              // ground layer - islas conectadas por puentes
              {
                name: "ground",
                offset: {
                  x: 0,
                  y: 4,
                },
                geometry: [
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 3, 3, 3, 0, 0, 3, 3, 3, 0, 0, 3, 3, 3, 0, 0],
                  [0, 3, 3, 3, 0, 0, 3, 3, 3, 0, 0, 3, 3, 3, 0, 0],
                  [0, 3, 3, 3, 3, 3, 3, 0, 3, 3, 3, 3, 3, 3, 0, 0],
                  [0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0],
                  [0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0],
                  [0, 3, 3, 3, 3, 3, 0, 0, 0, 3, 3, 3, 3, 3, 0, 0],
                  [0, 3, 3, 3, 0, 3, 3, 3, 3, 3, 0, 3, 3, 3, 0, 0],
                  [0, 3, 3, 3, 0, 0, 0, 3, 0, 0, 0, 3, 3, 3, 0, 0],
                  [0, 0, 3, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0, 0, 0],
                  [0, 0, 3, 0, 0, 3, 3, 3, 3, 3, 0, 0, 3, 0, 0, 0],
                  [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0],
                  [0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 0],
                  [0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0],
                  [0, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                ],
              },
              // Spawn, exit, monedas y puntos de decisin crticos
              {
                name: "onGround",
                offset: {
                  x: 0,
                  y: 0,
                },
                geometry: [
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 7, 17, 0, 0, 0, 0, 17, 0, 0, 0, 17, 0, 8, 0, 0],
                  [0, 0, 5, 0, 0, 0, 5, 0, 5, 0, 0, 0, 5, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 17, 0, 0, 0, 0, 0, 0, 0, 17, 0, 0, 0, 0],
                  [0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 17, 0, 0, 0, 17, 0, 0, 0, 0, 0, 0],
                  [0, 17, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 17, 0, 0],
                  [0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 17, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 17, 0, 0, 5, 0, 5, 0, 0, 17, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 17, 0, 0, 0, 0, 5, 0, 0, 0, 0, 17, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                ],
              }, // islands puzzle layer
            ],
          },

          {
            name: "map_13",
            tileset: "demo_tileset",
            // Twin Coordination Challenge - Inspirado en Lemmings
            layers: [
              // ground layer - terreno slido para coordinacin perfecta
              {
                name: "ground",
                offset: {
                  x: 0,
                  y: 4,
                },
                geometry: [
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                  [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                ],
              },
              // Coordinacin perfecta - timing crtico entre ambos piratas
              {
                name: "onGround",
                offset: {
                  x: 0,
                  y: 0,
                },
                geometry: [
                  [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
                  [4, 7, 6, 6, 5, 6, 6, 17, 6, 6, 5, 6, 6, 17, 8, 4],
                  [4, 4, 4, 6, 4, 4, 4, 4, 4, 4, 4, 6, 4, 4, 4, 4],
                  [4, 4, 4, 6, 4, 17, 6, 6, 6, 17, 4, 6, 4, 4, 4, 4],
                  [4, 4, 4, 6, 4, 6, 4, 5, 4, 6, 4, 6, 4, 4, 4, 4],
                  [4, 17, 6, 6, 6, 6, 4, 6, 4, 6, 6, 6, 6, 6, 17, 4],
                  [4, 4, 4, 5, 4, 6, 4, 6, 4, 6, 4, 5, 4, 4, 4, 4],
                  [4, 4, 4, 6, 4, 6, 6, 6, 6, 6, 4, 6, 4, 4, 4, 4],
                  [4, 4, 4, 6, 4, 4, 4, 17, 4, 4, 4, 6, 4, 4, 4, 4],
                  [4, 4, 4, 6, 6, 6, 6, 6, 6, 6, 6, 6, 4, 4, 4, 4],
                  [4, 4, 4, 5, 4, 4, 4, 11, 4, 4, 4, 5, 4, 4, 4, 4],
                  [4, 17, 6, 6, 6, 6, 4, 6, 4, 6, 6, 6, 6, 6, 17, 4],
                  [4, 4, 4, 6, 4, 6, 4, 5, 4, 6, 4, 6, 4, 4, 4, 4],
                  [4, 4, 4, 6, 4, 17, 6, 6, 6, 17, 4, 6, 4, 4, 4, 4],
                  [4, 7, 6, 6, 5, 6, 6, 17, 6, 6, 5, 6, 6, 17, 8, 4],
                  [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
                ],
              }, // twin coordination layer
            ],
          },
        ],
      };

      parameters.maps.forEach((map) => {
        new_layer = {};
        new_layer.name = "water";
        new_layer.look = "square";
        new_layer.offset = { x: 0, y: 8 };
        new_layer.geometry = Array(16)
          .fill()
          .map(() => Array(16).fill(0));
        map.layers.unshift(new_layer);
        //
        new_layer = {};
        new_layer.name = "splash";
        new_layer.offset = { x: 0, y: 8 };
        new_layer.geometry = Array(16)
          .fill()
          .map(() => Array(16).fill(0));
        map.layers.splice(2, 0, new_layer);

        let water = map.layers[0];
        let ground = map.layers[1];
        let splash = map.layers[2];

        for (let y = 0; y < ground.geometry.length; y++) {
          for (let x = 0; x < ground.geometry[0].length; x++) {
            if (
              y - 1 > 0 &&
              ground.geometry[y][x] !== 3 &&
              ground.geometry[y - 1][x] == 3
            ) {
              ground.geometry[y][x] = 2;
            }
          }
        }

        for (let y = 0; y < ground.geometry.length; y++) {
          for (let x = 0; x < ground.geometry[0].length; x++) {
            if (ground.geometry[y][x] == 2) {
              splash.geometry[y][x] = 16;
            }
          }
        }

        for (let y = 0; y < water.geometry.length; y++) {
          for (let x = 0; x < water.geometry[0].length; x++) {
            if (ground.geometry[y][x] == 3) {
              water.geometry[y][x] = 1;
            }

            if (ground.geometry[y][x] !== 3 && ground.geometry[y][x + 1] == 3) {
              water.geometry[y][x] = 1;
            }
            if (ground.geometry[y][x] !== 3 && ground.geometry[y][x - 1] == 3) {
              water.geometry[y][x] = 1;
            }
            if (
              y + 1 < water.geometry.length &&
              ground.geometry[y][x] !== 3 &&
              ground.geometry[y + 1][x] == 3
            ) {
              water.geometry[y][x] = 1;
            }
            if (
              y - 1 > 0 &&
              ground.geometry[y][x] !== 3 &&
              ground.geometry[y - 1][x] == 3
            ) {
              water.geometry[y][x] = 1;
            }
          }
        }

        for (let y = 0; y < water.geometry.length; y++) {
          for (let x = 0; x < water.geometry[0].length; x++) {
            if (water.geometry[y][x] == -1) {
              water.geometry[y][x] = 1;
            }
          }
        }
      });

      // ========== SCORE AND TIMER SYSTEM ==========
      let gameScore = 0;
      let levelTime = 30;
      let timerInterval = null;
      let showHUD_flag = false;
      const BASE_POINTS_PER_LEVEL = 100;

      // Surrender button variables (legacy - no longer used for positioning)
      let surrenderButtonX = 650;
      let surrenderButtonY = 100;
      let surrenderButtonSize = 160;

      function showHUD() {
        showHUD_flag = true;
        document.getElementById("gameHUD").style.display = "block";

        // Add event listener for surrender button (only once)
        const surrenderBtn = document.getElementById("surrenderBtn");
        if (surrenderBtn && !surrenderBtn.hasAttribute("data-listener-added")) {
          surrenderBtn.addEventListener("click", function () {
            // Farcade SDK: Haptic feedback for surrender button
            if (window.FarcadeSDK) {
              window.FarcadeSDK.singlePlayer.actions.hapticFeedback();
            }
            surrenderGame(game);
          });
          surrenderBtn.setAttribute("data-listener-added", "true");
        }

        // Also show hints during gameplay
        showHints();

        updateHUD();
      }

      function hideHUD() {
        showHUD_flag = false;
        document.getElementById("gameHUD").style.display = "none";
        if (timerInterval) {
          clearInterval(timerInterval);
          timerInterval = null;
        }

        // Also hide hints when hiding HUD
        hideHints();
      }

      function updateScore() {
        updateHUD();
      }

      function updateTimer() {
        updateHUD();
      }

      function updateHUD() {
        // Update score display
        const scoreElement = document.getElementById("scoreValue");
        if (scoreElement) {
          scoreElement.textContent = gameScore;
        }

        // Update timer display with color based on time remaining
        const timerElement = document.getElementById("timerValue");
        const timerDisplay = document.querySelector(".timer-display");
        if (timerElement && timerDisplay) {
          timerElement.textContent = levelTime;

          // Change color when time is low
          if (levelTime <= 10) {
            timerDisplay.style.color = "#ff4444";
            timerDisplay.style.textShadow = "3px 3px 0px rgba(255, 0, 0, 0.8)";
          } else {
            timerDisplay.style.color = "#ffffff";
            timerDisplay.style.textShadow = "3px 3px 0px rgba(0, 0, 0, 0.8)";
          }
        }
      }

      function startLevelTimer(gameWorld) {
        levelTime = 30;
        updateHUD();

        if (timerInterval) {
          clearInterval(timerInterval);
        }

        timerInterval = setInterval(() => {
          levelTime--;
          updateHUD();

          if (levelTime <= 0) {
            clearInterval(timerInterval);
            timerInterval = null;
            // Game Over - Time's up
            gameOverTimeUp(gameWorld);
          }
        }, 1000);
      }

      function calculateLevelScore(timeRemaining) {
        // Base points multiplied by time remaining multiplier
        // More time remaining = higher multiplier
        let timeMultiplier = 1 + timeRemaining / 30; // 1x to 2x multiplier
        return Math.floor(BASE_POINTS_PER_LEVEL * timeMultiplier);
      }

      function levelCompleted(gameWorld) {
        if (timerInterval) {
          clearInterval(timerInterval);
          timerInterval = null;
        }

        let levelPoints = calculateLevelScore(levelTime);
        gameScore += levelPoints;
        updateScore();

        // Farcade SDK: Haptic feedback for level completion
        if (window.FarcadeSDK) {
          window.FarcadeSDK.singlePlayer.actions.hapticFeedback();
        }

        // Keep HUD visible for a moment to show final score
        // Don't hide HUD here - let the transition handle it

        // Continue with normal level completion logic
      }

      function gameOverTimeUp(gameWorld) {
        hideHUD();
        stopAllMusic(); // Stop background music

        // Capture final score for SDK integration later
        console.log("GAME OVER - Final Score:", gameScore);

        // Farcade SDK: Report game over with score
        if (window.FarcadeSDK) {
          window.FarcadeSDK.singlePlayer.actions.gameOver({ score: gameScore });
        }

        // Reset game to level 1 for next play
        gameWorld.current_level = 1;
        resetGame();

        // Show the HTML Play button when returning to menu
        const menuPlayButton = document.getElementById("menuPlayButton");
        if (menuPlayButton) {
          menuPlayButton.style.display = "block";
        }

        // Return to menu (menu will start its own music)
        gameWorld.startScene("menu");
      }

      function surrenderGame(gameWorld) {
        hideHUD();
        stopAllMusic(); // Stop background music

        // Capture final score for SDK integration later
        console.log("GAME OVER - Player Surrendered - Final Score:", gameScore);

        // Farcade SDK: Report game over with score
        if (window.FarcadeSDK) {
          window.FarcadeSDK.singlePlayer.actions.gameOver({ score: gameScore });
        }

        // Reset game to level 1 for next play
        gameWorld.current_level = 1;
        resetGame();

        // Show the HTML Play button when returning to menu
        const menuPlayButton = document.getElementById("menuPlayButton");
        if (menuPlayButton) {
          menuPlayButton.style.display = "block";
        }

        // Return to menu (menu will start its own music)
        gameWorld.startScene("menu");
      }
      function resetGame() {
        gameScore = 0;
        levelTime = 30;
        updateScore();
        updateTimer();
      }

      // ========== HINTS SYSTEM ==========
      let currentHintIndex = 0;
      let hintInterval = null;
      let showHints_flag = false;

      const gameHints = [
        "Take all the coins, or not...",
        "Yo ho ho and a bottle of rum!",
        "Be fast and get more points...",
        "Dead men tell no tales...",
        "Coins give you more points...",
        "Aye, aye, Captain!",
        " Use red button to surrender (S key)",
        " Swipe on screen to move (mobile)",
      ];

      const HINT_FADE_SPEED = 0.02;
      const HINT_DISPLAY_DURATION = 5000; // 5 seconds (increased from 3)
      const HINT_FADE_DURATION = 500; // 0.5 seconds

      function showHints() {
        showHints_flag = true;
        console.log("Showing hints - setting display block");
        document.getElementById("gameHints").style.display = "block";

        // Start hint rotation if not already running
        if (!hintInterval) {
          console.log("Starting hint rotation");
          startHintRotation();
        }
      }

      function hideHints() {
        showHints_flag = false;
        document.getElementById("gameHints").style.display = "none";

        if (hintInterval) {
          clearInterval(hintInterval);
          hintInterval = null;
        }

        // Reset hint state
        currentHintIndex = 0;
        const hintElement = document.getElementById("hintText");
        if (hintElement) {
          hintElement.classList.remove("visible");
        }
      }

      function startHintRotation() {
        if (hintInterval) {
          clearInterval(hintInterval);
        }

        // Show first hint immediately
        displayCurrentHint();

        // Set up interval for hint rotation
        hintInterval = setInterval(() => {
          const hintElement = document.getElementById("hintText");
          if (hintElement) {
            // Fade out current hint
            hintElement.classList.remove("visible");

            // After fade transition, change text and fade in
            setTimeout(() => {
              currentHintIndex = (currentHintIndex + 1) % gameHints.length;
              displayCurrentHint();
            }, 300); // Match CSS transition duration
          }
        }, HINT_DISPLAY_DURATION);
      }

      function displayCurrentHint() {
        const hintElement = document.getElementById("hintText");
        console.log("displayCurrentHint called", {
          hintElement: !!hintElement,
          currentHintIndex,
          hint: gameHints[currentHintIndex],
        });

        if (hintElement && gameHints[currentHintIndex]) {
          hintElement.textContent = gameHints[currentHintIndex];
          // Small delay to ensure text is updated before fade in
          setTimeout(() => {
            hintElement.classList.add("visible");
            console.log("Added visible class to hint element");
          }, 50);
        }
      }
      // ========== END HINTS SYSTEM ==========

      // ========== BACKGROUND MUSIC SYSTEM ==========
      let currentBackgroundMusic = null;
      let pirateTracks = ["pirate1", "pirate2", "pirate3"];
      let currentTrackIndex = 0;
      let musicVolume = 0.08; // Softer volume level

      function stopAllMusic() {
        // Stop menu music
        if (
          game &&
          game.assets &&
          game.assets.audio &&
          game.assets.audio.jingle
        ) {
          game.assets.audio.jingle.audio.pause();
          game.assets.audio.jingle.audio.currentTime = 0;
        }

        // Stop any background music
        if (currentBackgroundMusic) {
          currentBackgroundMusic.pause();
          currentBackgroundMusic.currentTime = 0;
          currentBackgroundMusic = null;
        }
      }

      function playRandomPirateMusic() {
        if (!game || !game.assets || !game.assets.audio) return;

        // Stop any current background music
        if (currentBackgroundMusic) {
          currentBackgroundMusic.pause();
          currentBackgroundMusic = null;
        }

        // Randomly select a pirate track
        currentTrackIndex = Math.floor(Math.random() * pirateTracks.length);
        let trackName = pirateTracks[currentTrackIndex];

        if (
          game.assets.audio[trackName] &&
          game.assets.audio[trackName].audio
        ) {
          currentBackgroundMusic = game.assets.audio[trackName].audio;
          currentBackgroundMusic.volume = musicVolume;
          currentBackgroundMusic.currentTime = 0;
          currentBackgroundMusic.loop = false; // Don't loop, we'll pick random next

          // When track ends, play another random track
          currentBackgroundMusic.addEventListener(
            "ended",
            function () {
              // Small delay before next track to avoid performance issues
              setTimeout(() => {
                playRandomPirateMusic();
              }, 2000);
            },
            { once: true }
          );

          currentBackgroundMusic.play().catch((e) => {
            console.log("Could not play background music:", e);
          });
        }
      }

      function ensurePirateMusicPlaying() {
        // Only start pirate music if no music is currently playing
        if (
          !currentBackgroundMusic ||
          currentBackgroundMusic.paused ||
          currentBackgroundMusic.ended ||
          currentBackgroundMusic.currentTime === 0
        ) {
          console.log("Starting new pirate music...");
          playRandomPirateMusic();
        } else {
          console.log("Pirate music already playing, continuing...");
        }
      }

      function playMenuMusic() {
        stopAllMusic();

        if (
          game &&
          game.assets &&
          game.assets.audio &&
          game.assets.audio.jingle
        ) {
          game.assets.audio.jingle.audio.volume = musicVolume;
          game.assets.audio.jingle.audio.loop = true;
          game.assets.audio.jingle.audio.currentTime = 0;
          game.assets.audio.jingle.audio.play().catch((e) => {
            console.log("Could not play menu music:", e);
          });
        }
      }
      // ========== END BACKGROUND MUSIC SYSTEM ==========

      // ========== END SCORE AND TIMER SYSTEM ==========

      // menu scene
      let menu = new Scene("menu");
      menu.keyEvents = function (event) {
        // Only allow Arrow Keys and Space
        if (
          event.code !== "ArrowUp" &&
          event.code !== "ArrowDown" &&
          event.code !== "ArrowLeft" &&
          event.code !== "ArrowRight" &&
          event.code !== "Space"
        ) {
          return; // Ignore other keys
        }

        if (
          this.world.keys.ArrowDown &&
          this.selection < this.button.length - 1
        ) {
          // Removed sound for navigation - this.world.assets.audio.selection.audio.play();
          this.selection += 1;
        } else if (this.world.keys.ArrowUp && this.selection > 0) {
          // Removed sound for navigation - this.world.assets.audio.selection.audio.play();
          this.selection -= 1;
        }
        if (this.world.keys.Space) {
          this.world.assets.audio.selection.audio.play();

          // If PLAY is selected, ensure we start from level 1
          if (this.selection === 0) {
            // PLAY button
            this.world.current_level = 1;
            resetGame();
          }

          this.world.startScene(this.button[this.selection].link);
        }
      };

      // Add mouse and touch support for mobile devices
      menu.mouseEvents = function (event) {
        // Check if HTML Play button is visible - if so, ignore canvas touches
        const menuPlayButton = document.getElementById("menuPlayButton");
        if (menuPlayButton && menuPlayButton.style.display !== "none") {
          return; // Let the HTML button handle the interaction
        }

        if (event.type === "click" || event.type === "touchend") {
          let rect = this.world.canvas.getBoundingClientRect();
          let x =
            (event.clientX ||
              (event.touches && event.touches[0]
                ? event.touches[0].clientX
                : event.changedTouches[0].clientX)) - rect.left;
          let y =
            (event.clientY ||
              (event.touches && event.touches[0]
                ? event.touches[0].clientY
                : event.changedTouches[0].clientY)) - rect.top;

          // Scale coordinates to canvas resolution
          x = x * (this.world.W / rect.width);
          y = y * (this.world.H / rect.height);

          // Check if click is on any button
          for (let i = 0; i < this.button.length; i++) {
            let buttonY = this.select_pos.y + 35 + i * 45; // Updated spacing for multiple buttons
            let buttonWidth = this.button[i].name.length * 12; // Approximate button width
            let buttonHeight = 30; // Approximate button height

            if (
              x >= this.select_pos.x - buttonWidth / 2 &&
              x <= this.select_pos.x + buttonWidth / 2 &&
              y >= buttonY - buttonHeight / 2 &&
              y <= buttonY + buttonHeight / 2
            ) {
              this.selection = i;
              this.world.assets.audio.selection.audio.play();

              // If PLAY is selected, ensure we start from level 1
              if (this.selection === 0) {
                // PLAY button
                this.world.current_level = 1;
                resetGame();
              }

              this.world.startScene(this.button[this.selection].link);
              break;
            }
          }
        }
      };
      menu.init = function () {
        this.init_once = true;

        // Show HTML Play button for better mobile experience
        const menuPlayButton = document.getElementById("menuPlayButton");
        if (menuPlayButton) {
          menuPlayButton.style.display = "block";

          // Remove any existing event listeners to avoid duplicates
          menuPlayButton.onclick = null;

          // Add click/touch event listener
          menuPlayButton.onclick = () => {
            // Play selection sound
            if (this.world.assets.audio && this.world.assets.audio.selection) {
              this.world.assets.audio.selection.audio.play();
            }

            // Hide the button
            menuPlayButton.style.display = "none";

            // Start game
            this.world.current_level = 1;
            resetGame();
            this.world.startScene("inGame");
          };
        }

        // Play menu music (waves sound)
        playMenuMusic();

        // custom data
        this.button = [
          {
            name: "PLAY",
            link: "inGame",
          },
          {
            name: "LEVEL SELECT",
            link: "levels",
          },
        ];
        this.texteMax =
          Math.max(...this.button.map((button) => button.name.length)) * 6;
        this.selection = 0;
        this.select_pos = {
          x: this.world.W / 2,
          y: 125, // Back to previous position
        };
        // cursor removed - no longer needed
        // background
        let background_image = this.world.assets.image.pattern.image;
        this.pattern = this.world.ctx.createPattern(background_image, "repeat");
        this.offset = {
          x: 0,
          y: 0,
        };
        // add cat on
        this.cat = new Entity(
          this,
          -this.world.tile_size,
          -this.world.tile_size
        );
        let idle_sprite_data = {
          image: "pirate_captain_idle",
          size: {
            x: 32,
            y: 32,
          },
        };
        let walk_sprite_data = {
          image: "pirate_captain_walk",
          size: {
            x: 32,
            y: 32,
          },
        };
        this.cat.playerSprite = new PlayerSprite(
          this.cat,
          idle_sprite_data,
          walk_sprite_data
        );
        this.cat.playerSprite.offset = { x: 0, y: -8 };
      };
      menu.render = function () {
        this.animatedBackground();
        // Draw main title with high quality rendering
        let titleImage = this.world.assets.image["main_title"].image;
        let scaledWidth = titleImage.width / 2;
        let scaledHeight = titleImage.height / 2;

        // Save context and enable high quality image smoothing
        this.ctx.save();
        this.ctx.imageSmoothingEnabled = true;
        this.ctx.imageSmoothingQuality = "high";

        // Draw with precise positioning to avoid sub-pixel rendering
        this.ctx.drawImage(
          titleImage,
          0,
          0,
          titleImage.width,
          titleImage.height, // Source dimensions
          Math.floor(0),
          Math.floor(0), // Destination position (integer pixels)
          Math.floor(scaledWidth),
          Math.floor(scaledHeight) // Destination size (integer pixels)
        );

        this.ctx.restore();
        this.displaySelection();
        // notice with pirate fonts
        this.world.ctx.fillStyle = "rgba(0,0,0,0.6)";
        this.world.ctx.fillRect(0, this.world.H - 60, this.world.W, 50); // Increased height from 40 to 50 and adjusted Y position

        // Use smaller pirate font for menu instructions
        this.world.ctx.font = "16px 'Pirata One', sans-serif"; // Reduced from 18px to 16px
        this.world.ctx.fillStyle = "#FFD700";
        this.world.ctx.strokeStyle = "#8B4513";
        this.world.ctx.lineWidth = 2;
        this.world.ctx.textAlign = "center";

        // Arrow keys instruction
        this.world.ctx.strokeText(
          "Arrow keys to select",
          this.world.W / 2,
          this.world.H - 40
        );
        this.world.ctx.fillText(
          "Arrow keys to select",
          this.world.W / 2,
          this.world.H - 40
        );

        // Space to confirm instruction
        this.world.ctx.strokeText(
          "[Space] to Confirm",
          this.world.W / 2,
          this.world.H - 20
        );
        this.world.ctx.fillText(
          "[Space] to Confirm",
          this.world.W / 2,
          this.world.H - 20
        );
      };
      menu.displaySelection = function () {
        // Display the custom menu background image
        let menuImage = this.world.assets.image["menu_background"].image;

        // Calculate appropriate size and position for the menu image
        let menuWidth = menuImage.width / 2; // Scale down to half size for better fit
        let menuHeight = menuImage.height / 2;
        let menuX = (this.world.W - menuWidth) / 2; // Center horizontally
        let menuY = this.select_pos.y - 40; // Position above the buttons

        // Enable smooth rendering for the menu background
        this.ctx.save();
        this.ctx.imageSmoothingEnabled = true;
        this.ctx.imageSmoothingQuality = "high";

        // Draw the menu background image
        this.ctx.drawImage(
          menuImage,
          0,
          0,
          menuImage.width,
          menuImage.height, // Source
          menuX,
          menuY,
          menuWidth,
          menuHeight // Destination
        );

        this.ctx.restore();

        // Canvas button rendering enabled for testing - display multiple buttons
        // Display the buttons text over the image with pirate fonts
        for (i in this.button) {
          // Set pirate font and colors for buttons
          this.world.ctx.font = "36px 'Pirata One', sans-serif"; // Increased 50% from 24px to 36px
          this.world.ctx.textAlign = "center";
          this.world.ctx.lineWidth = 3; // Increased from 2 to 3 for thicker border

          // Different styling based on selection
          if (i == this.selection) {
            // Selected button - bright gold with pulsing animation
            let time = Date.now() * 0.003; // Slow pulsing speed
            let pulse = (Math.sin(time) + 1) / 2; // Oscillates between 0 and 1

            // Interpolate between the two colors based on pulse
            let brightGold = "#FFD700"; // Selected color
            let darkGold = "#B8860B"; // Base color

            // Create smooth color transition
            let r1 = parseInt(brightGold.substr(1, 2), 16);
            let g1 = parseInt(brightGold.substr(3, 2), 16);
            let b1 = parseInt(brightGold.substr(5, 2), 16);
            let r2 = parseInt(darkGold.substr(1, 2), 16);
            let g2 = parseInt(darkGold.substr(3, 2), 16);
            let b2 = parseInt(darkGold.substr(5, 2), 16);

            let r = Math.round(r2 + (r1 - r2) * pulse);
            let g = Math.round(g2 + (g1 - g2) * pulse);
            let b = Math.round(b2 + (b1 - b2) * pulse);

            this.world.ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
            this.world.ctx.strokeStyle = "#8B4513"; // Brown shadow
          } else {
            // Unselected button - static dark gold
            this.world.ctx.fillStyle = "#B8860B";
            this.world.ctx.strokeStyle = "#2F1B14";
          }

          let title = this.button[i].name;
          let x = this.select_pos.x;
          let y = this.select_pos.y + 35 + i * 45; // Increased spacing for two buttons

          // Draw text with outline
          this.world.ctx.strokeText(title, x, y);
          this.world.ctx.fillText(title, x, y);
        }

        // Cursor removed - no more hand icon pointing at buttons
      };
      menu.animatedBackground = function () {
        // Smooth ocean-like movement simulation
        let time = Date.now() * 0.001; // Convert to seconds for smooth animation

        // Create wave-like movement with multiple sine waves for more natural effect
        this.offset.x += 0.3 + Math.sin(time * 0.5) * 0.2; // Base movement + wave variation
        this.offset.y += 0.2 + Math.cos(time * 0.3) * 0.15; // Slower vertical movement

        // Add a secondary wave for more complex movement
        this.offset.x += Math.sin(time * 1.2) * 0.1;
        this.offset.y += Math.cos(time * 0.8) * 0.1;

        if (this.offset.x > 63) {
          this.offset.x = 0;
        }
        if (this.offset.y > 63) {
          this.offset.y = 0;
        }
        let ctx = this.world.ctx;
        ctx.save();
        ctx.translate(this.offset.x, this.offset.y);
        ctx.fillStyle = this.pattern;
        ctx.fillRect(
          -this.offset.x,
          -this.offset.y,
          this.world.W,
          this.world.H
        );
        ctx.restore();
      };
      let levels = new Scene("levels");
      levels.keyEvents = function (event) {
        // Only allow Arrow Keys and Space
        if (
          event.code !== "ArrowUp" &&
          event.code !== "ArrowDown" &&
          event.code !== "ArrowLeft" &&
          event.code !== "ArrowRight" &&
          event.code !== "Space"
        ) {
          return; // Ignore other keys
        }

        // Remove KeyE - only allow Arrow Keys and Space
        if (
          this.world.keys.ArrowDown &&
          this.selection + 5 < this.world.mapsMax
        ) {
          this.world.assets.audio.selection.audio.play();
          this.selection += 5;
        }
        if (this.world.keys.ArrowUp && this.selection - 5 >= 0) {
          this.world.assets.audio.selection.audio.play();
          this.selection -= 5;
        }
        if (
          this.world.keys.ArrowRight &&
          this.selection + 1 < this.world.mapsMax
        ) {
          this.world.assets.audio.selection.audio.play();
          this.selection += 1;
        }
        if (this.world.keys.ArrowLeft && this.selection - 1 >= 0) {
          this.world.assets.audio.selection.audio.play();
          this.selection -= 1;
        }
        if (this.world.keys.Space) {
          this.world.assets.audio.selection.audio.play();
          this.world.current_level = this.selection + 1;
          this.world.startScene("inGame");
        }
      };
      levels.init = function () {
        this.init_once = true;
        this.selection = 0;
        this.scale = 0;

        // Ensure pirate music is playing, but don't restart if already playing
        ensurePirateMusicPlaying();
      };
      levels.render = function () {
        this.world.clear("black");
        // animate selection
        this.scale += 0.1;
        if (this.scale > 1 / Math.sin(0.2)) {
          this.scale = -1;
        }
        let offset = Math.sin(this.scale) * 2;
        // display box
        this.ctx.fillStyle = "#82769e";
        this.world.drawBox(
          "box",
          16,
          16,
          this.world.W - 32,
          this.world.H - 46 - 32
        );
        // No need for bitmap fonts - using CSS fonts
        let show = Math.min(this.world.mapsMax, 20);
        for (let i = 0; i < show; i++) {
          let level_id = i + 20 * Math.floor(this.selection / 20);
          let position_x = 32 + Math.floor(i % 5) * 40,
            position_y = 32 + Math.floor(i / 5) * 40;
          if (level_id == this.selection) {
            // Selected level with glowing box
            this.world.drawBox(
              "selection",
              position_x - offset / 2,
              position_y - offset / 2,
              24 + offset,
              24 + offset
            );
          } else {
            // Unselected level with flat frame
            this.world.drawBox("flat_frame", position_x, position_y, 24, 24);
          }
          // Use pirate font for level numbers
          this.world.ctx.font = "16px 'Pirata One', sans-serif";
          this.world.ctx.textAlign = "center";
          this.world.ctx.lineWidth = 1;
          this.world.ctx.fillStyle = "#FFD700";
          this.world.ctx.strokeStyle = "#8B4513";

          let levelText = (level_id + 1).toString();
          this.world.ctx.strokeText(
            levelText,
            position_x + 13,
            position_y + 16
          );
          this.world.ctx.fillText(levelText, position_x + 13, position_y + 16);
        }
        // notice with pirate fonts for level selection
        this.world.ctx.fillStyle = "rgba(0,0,0,0.6)";
        this.world.ctx.fillRect(0, this.world.H - 60, this.world.W, 50); // Increased height from 33 to 50 and adjusted Y position

        // Use pirate font for level selection instructions
        this.world.ctx.font = "18px 'Pirata One', sans-serif";
        this.world.ctx.fillStyle = "#FFD700";
        this.world.ctx.strokeStyle = "#8B4513";
        this.world.ctx.lineWidth = 2;
        this.world.ctx.textAlign = "center";

        // Arrow keys instruction
        this.world.ctx.strokeText(
          "Arrow keys to select",
          this.world.W / 2,
          this.world.H - 40
        );
        this.world.ctx.fillText(
          "Arrow keys to select",
          this.world.W / 2,
          this.world.H - 40
        );

        // Space to confirm instruction
        this.world.ctx.strokeText(
          "[Space] to Confirm",
          this.world.W / 2,
          this.world.H - 20
        );
        this.world.ctx.fillText(
          "[Space] to Confirm",
          this.world.W / 2,
          this.world.H - 20
        );
      };
      let inGame = new Scene("inGame");
      inGame.keyEvents = function (event) {
        // Only allow Arrow Keys, Space, and S for surrender
        if (
          event.code !== "ArrowUp" &&
          event.code !== "ArrowDown" &&
          event.code !== "ArrowLeft" &&
          event.code !== "ArrowRight" &&
          event.code !== "Space" &&
          event.code !== "KeyS"
        ) {
          return; // Ignore other keys
        }

        // Handle surrender with S key
        if (event.code === "KeyS" && event.type === "keydown") {
          // Farcade SDK: Haptic feedback for surrender key
          if (window.FarcadeSDK) {
            window.FarcadeSDK.singlePlayer.actions.hapticFeedback();
          }
          surrenderGame(game);
          return;
        }

        // Remove E and R key handling - only allow Arrow Keys and Space
      };
      inGame.init = function () {
        this.won = false;
        this.userInput = true;
        this.world.initMap("map_" + this.world.current_level);

        // Hide HTML Play button when entering game
        const menuPlayButton = document.getElementById("menuPlayButton");
        if (menuPlayButton) {
          menuPlayButton.style.display = "none";
        }

        // Ensure pirate music is playing, but don't restart if already playing
        ensurePirateMusicPlaying();

        // Show HUD and start timer - ensure HUD is always visible during gameplay
        showHUD();
        updateScore();
        startLevelTimer(this.world);

        this.cats = [];
        let spawn_cat = () => {
          // add cats on spawn tile_size
          let spawns = this.world.findTile(3, 7);
          spawns.forEach((spawn) => {
            this.addCat(spawn.x, spawn.y);
          });
        };

        // effects
        this.effects = [];
        // transition effects
        this.transition = {
          scene: this,
          active: true,
          // between 0 and 100
          state: 0,
          value: 0,
          duration: 500,
          start: 0,
          // between whatever and whatever
          from: 0,
          to: Math.max(this.world.W, this.world.H),
          //
          start: function (from, to, callback) {
            this.scene.userInput = false;
            this.active = true;
            this.from = from;
            this.start_time = new Date();
            this.to = to;
            this.callback = callback;
          },
          update: function () {
            let time = new Date() - this.start_time;
            if (time < this.duration) {
              this.value = Util.easeInOutQuad(
                time,
                this.from,
                this.to - this.from,
                this.duration
              );
            } else {
              this.active = false;
              this.scene.userInput = true;
              if (this.callback !== undefined) {
                this.callback();
              }
            }
          },
          render: function () {
            this.scene.ctx.fillStyle = "black";
            this.scene.ctx.fillRect(0, 0, this.scene.world.W, this.value);
            this.scene.ctx.fillRect(
              0,
              this.scene.world.H,
              this.scene.world.W,
              -this.value
            );
            this.scene.ctx.fillRect(0, 0, this.value, this.scene.world.H);
            this.scene.ctx.fillRect(
              this.scene.world.W,
              0,
              -this.value,
              this.scene.world.H
            );
          },
        };
        this.transition.start(
          Math.max(this.world.W / 2, this.world.H / 2),
          0,
          spawn_cat
        );
      };
      inGame.addCat = function (x, y) {
        let cat = new Cat(this, x, y);
        let idle_sprite_data = {
          image: "pirate_captain_idle",
          size: {
            x: 32,
            y: 32,
          },
        };
        let walk_sprite_data = {
          image: "pirate_captain_walk",
          size: {
            x: 32,
            y: 32,
          },
        };
        cat.playerSprite = new PlayerSprite(
          cat,
          idle_sprite_data,
          walk_sprite_data
        );
        cat.playerSprite.offset = { x: 0, y: -8 };
        let spawn_data = {
          image: "spawn_effect",
          frames: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12],
          size: {
            x: 20,
            y: 40,
          },
        };
        let spawn_effect = new Effect(this, spawn_data, x, y - 1, () => {
          this.cats.push(cat);
        });
        spawn_effect.trigger = 4;
        this.effects.push(spawn_effect);
      };

      inGame.render = function () {
        this.control();
        this.world.renderMap();

        for (let i = this.cats.length; i--; ) {
          this.cats[i].playerSprite.animate();
          // draw shadow and cat
          this.ctx.drawImage(
            this.world.assets.image["shadow"].image,
            this.cats[i].body.position.x,
            this.cats[i].body.position.y + 2
          );
          this.cats[i].playerSprite.display();
          this.cats[i].translation();
        }
        for (let i = this.effects.length; i--; ) {
          this.effects[i].render();
        }
        if (this.transition.active) {
          this.transition.update();
          this.transition.render();
        }

        // Update HUD if visible (now rendered outside canvas)
        if (showHUD_flag) {
          updateHUD();
        }
      };

      // Global function to render scaled sprite text on external canvas
      function renderScaledTextOnCanvas(ctx, text, centerX, y, scale, colorID) {
        // Wait for game to be fully loaded
        if (
          !game ||
          !game.fonts ||
          !game.currentFont ||
          !game.fonts[game.currentFont]
        ) {
          // Fallback: render with browser font temporarily
          ctx.font = "bold " + 16 * scale + "px monospace";
          ctx.fillStyle = colorID === 1 ? "#ff4444" : "#ffffff";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.strokeStyle = "#000000";
          ctx.lineWidth = 2;
          ctx.strokeText(text, centerX, y);
          ctx.fillText(text, centerX, y);
          return;
        }

        let size_x = game.fonts[game.currentFont].size.x;
        let size_y = game.fonts[game.currentFont].size.y;
        let font_img = game.fonts[game.currentFont].image;

        // Make sure the font image is loaded
        if (!font_img || !font_img.complete) {
          // Use fallback again if image not ready
          ctx.font = "bold " + 16 * scale + "px monospace";
          ctx.fillStyle = colorID === 1 ? "#ff4444" : "#ffffff";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.strokeStyle = "#000000";
          ctx.lineWidth = 2;
          ctx.strokeText(text, centerX, y);
          ctx.fillText(text, centerX, y);
          return;
        }

        // Calculate total width of scaled text for centering
        let totalWidth = text.length * size_x * scale;
        let startX = centerX - totalWidth / 2;

        // Render each character with scaling
        for (let i = 0; i < text.length; i++) {
          let char = text.charAt(i);
          let index = game.alphabet.indexOf(char);
          if (index !== -1) {
            let clipX = size_x * index;
            let posX = startX + i * size_x * scale;

            try {
              ctx.drawImage(
                font_img,
                clipX,
                colorID * size_y,
                size_x,
                size_y,
                posX,
                y - (size_y * scale) / 2,
                size_x * scale,
                size_y * scale
              );
            } catch (e) {
              // Fallback if drawImage fails
              console.warn("Failed to draw sprite character:", char, e);
            }
          }
        }
      }

      // Add touch support for mobile devices in game
      inGame.mouseEvents = function (event) {
        if (!this.userInput) return;

        // The improved touch handling is now managed by the main engine
        // This function mainly handles any game-specific mouse/touch interactions
        // that aren't movement-related (e.g., UI interactions)

        // For movement, we rely on the improved touch system in the main engine
        // which handles hold gestures, continuous movement, and better zone detection
      };

      inGame.control = function () {
        if (this.userInput == false) return false;
        if (this.world.keys.ArrowUp) {
          this.moveCats(0, -1);
        }
        if (this.world.keys.ArrowDown) {
          this.moveCats(0, 1);
        }
        if (this.world.keys.ArrowLeft) {
          this.moveCats(-1, 0);
        }
        if (this.world.keys.ArrowRight) {
          this.moveCats(1, 0);
        }
      };
      inGame.moveCats = function (x, y) {
        // see if every cat are ready to move
        let canMove = this.cats.every((cat) => {
          return cat.inTranslation == false;
        });
        if (!canMove) return false;
        this.cats.forEach((cat) => {
          if (cat.canBeControlled === false) return false;
          if (cat.isDead) return false;
          cat.move(x, y);
        });
        this.collisionCats();
        this.cats.forEach((cat) => {
          cat.applyMove();
        });
      };
      inGame.collisionCats = function () {
        // check for other cats !
        let need_to_check = true;
        while (need_to_check === true) {
          need_to_check = false;
          this.cats.forEach((cat) => {
            if (cat.checkOthers()) {
              cat.target = cat.old_position.copy();
              need_to_check = true;
            }
          });
        }
      };

      inGame.collisionCoins = function () {
        // Check if cats are on coin tiles
        this.cats.forEach((cat) => {
          // Check both layers for coins
          let tileLayer1 = this.world.getTile(1, cat.target.x, cat.target.y);
          let tileLayer3 = this.world.getTile(3, cat.target.x, cat.target.y);

          // Check for coin in either layer
          let coinFound = false;
          let coinLayer = null;

          if (tileLayer1 && tileLayer1.name === "coin") {
            coinFound = true;
            coinLayer = 1;
          } else if (tileLayer3 && tileLayer3.name === "coin") {
            coinFound = true;
            coinLayer = 3;
          }

          if (coinFound) {
            // Remove the coin from the map
            this.world.setTile(coinLayer, cat.target.x, cat.target.y, 0);

            // Remove coin from animated cache to stop rendering
            let layer = this.world.terrain.layers[coinLayer];
            if (layer.animated) {
              layer.animated.forEach((animatedTile) => {
                if (animatedTile.id == "17") {
                  // coin tile id
                  animatedTile.positions = animatedTile.positions.filter(
                    (pos) => !(pos.x === cat.target.x && pos.y === cat.target.y)
                  );
                }
              });
            }

            // Add bonus points for collecting coin
            gameScore += 100;
            updateHUD();

            // Farcade SDK: Haptic feedback for collecting coin
            if (window.FarcadeSDK) {
              window.FarcadeSDK.singlePlayer.actions.hapticFeedback();
            }

            // Play coin collection sound
            if (
              this.world.assets.audio.coin_collect &&
              this.world.assets.audio.coin_collect.audio
            ) {
              try {
                this.world.assets.audio.coin_collect.audio.currentTime = 0;
                this.world.assets.audio.coin_collect.audio.play().catch((e) => {
                  console.log("Could not play coin collection sound:", e);
                });
              } catch (error) {
                console.log("Error playing coin sound:", error);
              }
            }
          }
        });
      };

      inGame.checkWin = function () {
        if (this.cats.length === 0) {
          // No cats left - Game Over (this should not normally be reached
          // since individual cat death now triggers immediate game over)
          hideHUD();
          stopAllMusic();
          console.log("GAME OVER - All pirates lost - Final Score:", gameScore);

          // Farcade SDK: Report game over with score
          if (window.FarcadeSDK) {
            window.FarcadeSDK.singlePlayer.actions.gameOver({
              score: gameScore,
            });
          }

          // Reset game to level 1 for next play
          this.world.current_level = 1;
          resetGame();

          // Show the HTML Play button when returning to menu
          const menuPlayButton = document.getElementById("menuPlayButton");
          if (menuPlayButton) {
            menuPlayButton.style.display = "block";
          }

          // Return to menu
          this.world.startScene("menu");
          return false;
        }
        let win = this.cats.every((cat) => {
          let tile = this.world.getTile(3, cat.target.x, cat.target.y);
          return tile.name == "exit";
        });
        if (
          win === true &&
          this.cats.length >= this.world.findTile(3, 8).length &&
          !this.won
        ) {
          this.won = true;

          // Play completion sound with error handling
          if (
            this.world.assets.audio.selection &&
            this.world.assets.audio.selection.audio
          ) {
            try {
              this.world.assets.audio.selection.audio.currentTime = 0;
              this.world.assets.audio.selection.audio.play().catch((e) => {
                console.log("Could not play selection audio:", e);
              });
            } catch (error) {
              console.log("Error playing completion sound:", error);
            }
          } else {
            console.log("Selection audio not available");
          }

          // Level completed - calculate and add score
          levelCompleted(this.world);

          if (
            this.world.maps["map_" + (this.world.current_level + 1)] !==
            undefined
          ) {
            this.transition.start(
              0,
              Math.max(this.world.W / 2, this.world.H / 2),
              () => {
                this.world.current_level += 1;
                this.world.startScene("inGame");
              }
            );
          } else {
            // All levels completed - capture final score and reset game
            this.transition.start(
              0,
              Math.max(this.world.W / 2, this.world.H / 2),
              () => {
                hideHUD();
                stopAllMusic(); // Stop background music
                console.log(
                  "GAME COMPLETED - All levels finished - Final Score:",
                  gameScore
                );

                // Farcade SDK: Report game completion with final score
                if (window.FarcadeSDK) {
                  window.FarcadeSDK.singlePlayer.actions.gameOver({
                    score: gameScore,
                  });
                }

                // Reset game to level 1 for next play
                this.world.current_level = 1;
                resetGame();

                // Show the HTML Play button when returning to menu
                const menuPlayButton =
                  document.getElementById("menuPlayButton");
                if (menuPlayButton) {
                  menuPlayButton.style.display = "block";
                }

                // Return to menu (menu will start its own music)
                this.world.startScene("menu");
              }
            );
          }
        }
      };
      // destroy itself when animation is finish
      class Effect extends Entity {
        constructor(scene, sprite_data, x, y, callback) {
          super(scene, x * scene.world.tile_size, y * scene.world.tile_size);
          this.setSprite(sprite_data);
          this.sprite.addAnimation("full", sprite_data.frames);
          this.sprite.speed = 0.4;
          this.sprite.offset.y = -3;
          this.trigger = sprite_data.frames.length;
          this.callback = callback || undefined;
        }
        render() {
          if (this.sprite.current_frame + 1 === this.trigger) {
            if (this.callback !== undefined) {
              this.callback();
              this.callback = undefined;
            }
          }
          if (
            this.sprite.current_frame + 1 ===
            this.sprite.animations[this.sprite.current_animation].length
          ) {
            this.scene.effects.splice(this.scene.effects.indexOf(this), 1);
          }
          this.sprite.animate("full");
          this.display();
        }
      }
      class Cat extends Entity {
        constructor(scene, x, y) {
          super(scene, x * scene.world.tile_size, y * scene.world.tile_size);
          this.old_position = new Vector(x, y);
          this.target = new Vector(x, y);
          this.canBeControlled = true;
          this.inTranslation = false;
          this.lastDirection = new Vector(0, 0);
          this.isDead = false;
          // Trasnlation of the cat when they move
          this.transition = {
            start: new Date(),
            duration: 300,
            type: Util.easeInOutQuad,
            start_pos: new Vector(),
          };
        }
        // apply translation on cat when necessary
        translation() {
          if (this.inTranslation) {
            // get current time !
            let time = new Date() - this.transition.start;
            if (time < this.transition.duration) {
              let x = this.transition.type(
                  time,
                  this.transition.start_pos.x,
                  this.transition.target.x - this.transition.start_pos.x,
                  this.transition.duration
                ),
                y = this.transition.type(
                  time,
                  this.transition.start_pos.y,
                  this.transition.target.y - this.transition.start_pos.y,
                  this.transition.duration
                );
              this.body.position = new Vector(x, y);
            } else {
              // apply position when translation is finish :) !
              this.old_position = this.target.copy();
              let next_move = this.target.copy();
              next_move.mult(this.world.tile_size);
              this.body.position = next_move;
              this.inTranslation = false;
              if (this.isDead) {
                // delete cat
                let spawn_data = {
                  image: "water_splash",
                  frames: [0, 1, 2, 3, 4, 5, 6, 7, 8],
                  size: {
                    x: 20,
                    y: 32,
                  },
                };
                let spawn_effect = new Effect(
                  this.scene,
                  spawn_data,
                  this.target.x,
                  this.target.y - 1,
                  () => {
                    this.scene.cats.splice(this.scene.cats.indexOf(this), 1);
                    this.world.assets.audio.splash.audio.play();

                    // Farcade SDK: Haptic feedback for falling in water
                    if (window.FarcadeSDK) {
                      window.FarcadeSDK.singlePlayer.actions.hapticFeedback();
                    }

                    // Game Over immediately when ANY pirate falls into water
                    hideHUD();
                    stopAllMusic(); // Stop background music
                    console.log(
                      "GAME OVER - Pirate fell into water - Final Score:",
                      gameScore
                    );

                    // Farcade SDK: Report game over with score
                    if (window.FarcadeSDK) {
                      window.FarcadeSDK.singlePlayer.actions.gameOver({
                        score: gameScore,
                      });
                    }

                    // Reset game to level 1 for next play
                    this.world.current_level = 1;
                    resetGame();

                    // Show the HTML Play button when returning to menu
                    const menuPlayButton =
                      document.getElementById("menuPlayButton");
                    if (menuPlayButton) {
                      menuPlayButton.style.display = "block";
                    }

                    // Return to menu (menu will start its own music)
                    this.world.startScene("menu");
                  }
                );
                spawn_effect.sprite.offset.y = 0;
                spawn_effect.trigger = 2;
                this.scene.effects.push(spawn_effect);
              }
              if (this.canBeControlled === false) {
                this.move(this.lastDirection.x, this.lastDirection.y);
                this.scene.collisionCats();
                this.applyMove();
              } else {
                // check arrows
                let current_tile = this.world.getTile(
                  3,
                  this.target.x,
                  this.target.y
                );
                switch (current_tile.name) {
                  case "arrowRight":
                    this.move(1, 0);
                    this.scene.collisionCats();
                    this.applyMove();
                    break;
                  case "arrowLeft":
                    this.move(-1, 0);
                    this.scene.collisionCats();
                    this.applyMove();
                    break;
                  case "arrowUp":
                    this.move(0, -1);
                    this.scene.collisionCats();
                    this.applyMove();
                    break;
                  case "arrowDown":
                    this.move(0, 1);
                    this.scene.collisionCats();
                    this.applyMove();
                    break;
                  default:
                }
              }
              // check if we won when a cat finish a step
              this.scene.checkWin();
              this.scene.collisionCoins(); // Check for coin collection after movement
            }
          }
        }
        move(x, y) {
          this.target = this.old_position.copy();
          let direction = new Vector(x, y);
          // get future position
          let future_position = this.target.copy();
          future_position.add(direction);
          let layers = this.world.terrain.layers;
          let future_tile = layers.map((layer) => {
            let index = layers.indexOf(layer);
            return this.world.getTile(
              index,
              future_position.x,
              future_position.y
            );
          });
          let collision = future_tile.every((tile) => {
            if (tile == false) {
              return tile == false;
            } else {
              return tile.collision === false;
            }
          });
          if (collision == true) {
            this.target.add(direction);
          }
          if (future_tile[3].name === "ice") {
            this.canBeControlled = false;
            this.transition.type = Util.linearTween;
            this.transition.duration = 100;
            return false;
          }
          if (future_tile[3].name === "trap") {
            let dust_data = {
              image: "dust_effect",
              frames: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12],
              size: {
                x: 32,
                y: 32,
              },
            };
            let dust_effect = new Effect(
              this.scene,
              dust_data,
              this.target.x,
              this.target.y
            );
            this.scene.effects.push(dust_effect);
            this.world.assets.audio.eboulement.audio.play();

            this.world.terrain.layers[3].geometry[future_position.y][
              future_position.x
            ] = 10;
            // cache the map
            this.world.terrainCache(this.world.terrain.layers[3]);
            return false;
          }
          if (future_tile[1].name !== "ground") {
            this.transition.type = Util.easeInOutQuad;
            this.transition.duration = 200;
            this.isDead = true;
            return false;
          } else {
            this.canBeControlled = true;
            this.transition.type = Util.easeInOutQuad;
            this.transition.duration = 200;
            return false;
          }
        }
        applyMove() {
          // prevent cat to move if his target equal his actual position :V
          if (
            this.old_position.x === this.target.x &&
            this.old_position.y === this.target.y
          ) {
            this.canBeControlled = true;
            return false;
          }
          this.lastDirection = new Vector(
            this.target.x - this.old_position.x,
            this.target.y - this.old_position.y
          );
          this.shouldMove = false;
          this.transition.start_pos = this.old_position.copy();
          this.transition.start_pos.mult(this.world.tile_size);
          this.transition.target = this.target.copy();
          this.transition.target.mult(this.world.tile_size);
          this.transition.start = new Date();
          this.inTranslation = true;
        }
        checkOthers() {
          let others = this.scene.cats;
          let result = false;
          for (let i = 0; i < others.length; i++) {
            if (this === others[i]) continue;
            if (
              others[i].target.x === this.target.x &&
              others[i].target.y === this.target.y
            ) {
              result = true;
              break;
            }
          }
          return result;
        }
      }
      // Controls scene removed - not needed since we only use Arrow Keys + Space

      let game = new Diorama(parameters);
      // global variables
      game.current_level = 1;
      // Add the different scenes here
      // the addScene function link the scene with the world (game)
      game.addScene(menu);
      game.addScene(levels);
      // game.addScene(controls); // Removed - not needed
      game.addScene(inGame);
      game.ready();
      // everything start being loaded now !
      // the ready function must be called last !

      // Farcade SDK: Game is ready to play
      if (window.FarcadeSDK) {
        window.FarcadeSDK.singlePlayer.actions.ready();

        // Handle play again requests
        window.FarcadeSDK.on("play_again", () => {
          // Reset game state and start new game
          game.current_level = 1;
          game.score = 0;
          levelTime = 30;

          // Show the HTML Play button when returning to menu
          const menuPlayButton = document.getElementById("menuPlayButton");
          if (menuPlayButton) {
            menuPlayButton.style.display = "block";
          }

          game.startScene("menu");
        });

        // Handle mute/unmute toggle
        window.FarcadeSDK.on("toggle_mute", (data) => {
          // Set game audio based on data.isMuted
          if (data.isMuted) {
            game.soundLevel(0);
            stopAllMusic();
          } else {
            game.soundLevel(0.1);
            // Resume appropriate music based on current scene
            if (game.current_scene && game.current_scene.name === "menu") {
              ensureMenuMusicPlaying();
            } else if (
              game.current_scene &&
              game.current_scene.name === "inGame"
            ) {
              ensurePirateMusicPlaying();
            }
          }
        });
      }

      // Making the game full screen and with a softer audio volume by default
      game.soundLevel(0.1);
      game.fullScreen();
    </script>
  </body>
</html>
